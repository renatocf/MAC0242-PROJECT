options 
{
    STATIC    = false ;
    LOOKAHEAD = 2;
}
PARSER_BEGIN(Parser)

package parser;
import parser.*;
import java.util.HashMap;
import java.util.Stack;
import java.util.ArrayList;
import exception.WrongTypeException;
import exception.UndefinedFunctionException;
import exception.MissingReturnException;

/**
 * <b>Parser for user Program<b>
 * @author Renato Cordeiro Ferreira
 * @author Vinicius Nascimento Silva
 */
public class Parser 
{
    Stack<HashMap<String,String>> scope     = new Stack<HashMap<String,String>>();
    String                        actual    = "main";
    HashMap<String,String>        returns   = new HashMap<String,String>();
    HashMap<String,Parameters>    functions = new HashMap<String,Parameters>();
    
    public static void main( String[] args )
        throws ParseException, 
               TokenMgrError, 
               WrongTypeException,
               UndefinedFunctionException,
               MissingReturnException
    {
        Parser parser = new Parser(System.in);
        parser.Start(); 
    }
}

PARSER_END(Parser)

SKIP : { " " | "\n" | "\r" | "\r\n" | "\t" }

TOKEN : {< LBRACE : "(" >}
TOKEN : {< RBRACE : ")" >}
TOKEN : {< LCURLY : "{" >}
TOKEN : {< RCURLY : "}" >}

TOKEN : {< DEF : "def" >}
TOKEN : {< RET : "return" >}
TOKEN : {< TYPE : "number" | "string" | "void" >}

TOKEN : {< NUMBER   : (["0"-"9"])+  ("." (["0"-"9"])+)? >}
TOKEN : {< STRING   : ( ("\"") (~["\""])* ("\"")) >}

TOKEN : {< SIGN : "+"  | "-"  >}
TOKEN : {< OP   : "*"  | "/" | "%" >}
TOKEN : {< CMP  : "==" | "!=" | "<" | "<=" | ">=" | ">" >}
TOKEN : {< ATTR : "="  | "+=" | "-=" | "*=" | "/=" | "%=" >}

TOKEN : {< WORD   : (["A"-"Z"] |  ["a"-"z"] | "_")+ >}
TOKEN : {< EOL : ";" >}
/**
 * 
 * 
 * 
 */

/**
 * Defines program expressions.
 */ 
void Start() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException :
{
    String s;
    HashMap<String,String> main = new HashMap<String,String>();
}    
{
    { scope.push(main); }
    (
        (
                prototype()
            |
                function()
            |
                <EOL>
            |
            (
                s = expression()
                { insert("POP"); }
                <EOL>
            )
        )
        { say("--------------------------------"); }
        { actual = "main"; }
    )*
}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                             FUNCTIONS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
ArrayList<String[]> header() 
    throws UndefinedFunctionException :
{
    Token t, f, s1, s2;
    Parameters parameter;
    String[] aux = new String[2];
    ArrayList<String[]> vars = new ArrayList<String[]>();
    ArrayList<String> types = new ArrayList<String>();
}
{
    t = <TYPE>
    f = <WORD>
    <LBRACE>
    (
        s1 = <TYPE>
        { types.add(s1.image); }
        { aux[0] = s1.image; }
        (
            s2 = <WORD>
            { aux[1] = s2.image; }
        )?
        {
            vars.add(aux);
            aux = new String[2];
        }
        (
            ","
            s1 = <TYPE>
            { types.add(s1.image); }
            { aux[0] = s1.image; }
            (
                s2 = <WORD>
                { aux[1] = s2.image; }
            )?
            {
                vars.add(aux);
                aux = new String[2];
            }
        )*
    )?
    <RBRACE>
    { parameter = new Parameters(types.toArray(new String[0])); }
    {   
        if (functions.containsKey(f.image))
        {
            if(functions.get(f.image).getSize() != parameter.getSize())
                throw new UndefinedFunctionException(f.image);
        }
        else        
            functions.put(f.image, parameter);
    }
    
    {   
        if (returns.containsKey(f.image))
        {
            if(!returns.get(f.image).equals(t.image))
                throw new UndefinedFunctionException(f.image);
        }
        else
            returns.put(f.image, t.image);                          
    }
        
    {
        actual = f.image; 
        return vars; 
    }
}


void prototype() 
    throws UndefinedFunctionException :
{
}
{
    <DEF>
    header()
    <EOL>
}

void function() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException :
{
    ArrayList<String[]> vars;
    boolean returned = false;
    String s;
}
{
    vars = header()
    { scope.push(new HashMap<String,String>()); }
    { insert(actual + ":"); }
    <LCURLY>
    {
        for(int i = vars.size() -1; i >= 0; i--)
        {
            if(vars.get(i)[0] == null || vars.get(i)[1] == null)
                throw new UndefinedFunctionException(actual);
            attr(vars.get(i)[1], "=", vars.get(i)[0]);
            insert("POP");
        }    
    }
    (
        (
            expression()
            <EOL>
        )
        |
        (
            <RET>
            s = expression()
            {
                if(!returns.get(actual).equals(s))
                    throw new WrongTypeException(returns.get(actual));
            }
            <EOL>
            { insert("RET"); }
            { returned = true;}
        )
    )*
    <RCURLY>
    { 
        if(!returned && !returns.get(actual).equals("void")) 
            throw new MissingReturnException(actual); 
    }
    { scope.pop(); }
}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                            EXPRESSIONS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
        
/**
 * Expression is a comparison of Arit's.
 */
String expression() 
    throws WrongTypeException, 
           UndefinedFunctionException :
{
    Token   t;
    String s = "";
}
{
    s = arit()
    (
        t = <CMP>
        { checkTypeError(s); }            
        s = arit()
        { checkTypeError(s); }
        { insert(cmp(t)); }
    )*
    { return s; }
}

/**
 * Arit is a sum of terms.
 */
String arit() 
    throws WrongTypeException, 
           UndefinedFunctionException :
{
    Token   t;
    String  s = "";
}
{
    s = term()
    (
        t = <SIGN>            
        { checkTypeError(s); }
        s = term() 
        { checkTypeError(s); }
        { insert(sign(t)); }
    )*
    { return s; }
}

/**
 * Term is a product of elements.
 */
String term () 
    throws WrongTypeException, 
           UndefinedFunctionException :
{
    Token  t;
    double value;
    String s = "";
}
{
    s = element()
    (
        t = <OP>
        { checkTypeError(s); }
        s = element()
        { checkTypeError(s); }
        { insert(op(t)); }
    )*
    { return s; }
}

/**
 * Element is either a factor or a signed factor.
 */
String element() 
    throws WrongTypeException, 
           UndefinedFunctionException :
{
    Token t;
    String s = "";;
}
{
    (s = factor()
    { return s; })
    |
    (
        t = <SIGN>
        s = factor()
        { checkTypeError(s); }
        { unarySign(t); }
        { return s; }
    )
    {return s;}
    
}

/**
 * Factor is either a attribution, a variable, 
 * a number or a braced expression.
 */
String factor ()  
    throws WrongTypeException, 
           UndefinedFunctionException :
{
    Token t, v;
    double   value;
    String s = "";
    int i = 0;
    Parameters p;
}
{    
    (
        t = <WORD> 
        v = <ATTR>
        s = expression()
        { attr(t.image, v.image, s);
            return s; }
    )
    |
    (
        t = <WORD>
        { 
            p = functions.get(t.image);
            if(p == null)
            {throw new UndefinedFunctionException(t.image);} 
        }
        <LBRACE>
        (
            s = expression()
            {
                if (i == p.getSize())
                    throw new UndefinedFunctionException(t.image);   
                if(!s.equals(p.getType(i++)))
                    throw new WrongTypeException(
                        p.getType(i-1) + " on argument " + i
                        + " at function '" + t.image + "'"
                    );
            } 
            (
                "," 
                s = expression()
                {
                    if (i == p.getSize())
                        throw new UndefinedFunctionException(t.image);
                    if(!s.equals(p.getType(i++)))
                       throw new WrongTypeException(
                        "at function '" + t.image + "': " 
                        + p.getType(i-1) + " on position " + i
                    );
                }
            )*
        )?
        {
            if (i != p.getSize())
                throw new UndefinedFunctionException(t.image);
        }
        <RBRACE>
        { s = call(t.image); }
        { return s; }
    )
    |
        t = <WORD>
        { s = get(t); }
        { return s; }
    |
        (
        t = <STRING>
        { PUSH(t.image);     }
        { return "string"; }
    )
    |
    (
        t = <NUMBER>
        { value = atof(t); }
        { PUSH(value);     }
        { return "number"; }
    )
    |
    (
        <LBRACE> 
        s = expression()
        <RBRACE>
        { return s; }
    )
    
}

/**
 * Auxiliar function for 
 * pushing in the assembly.
 * @param o Pushed object
 */
void PUSH(Object o) :
{}
{{    
    insert("PUSH ", o);
}}

/**
 * Print string representation of | "%"
 * a variable number of objects.
 * @param obj List of objects
 */
void insert(Object ... obj) :
{
    String s;
}
{{
    for(Object o: obj)
    {
        s = (o == null)? "null" : o.toString();
        System.out.print(s);
    }
    System.out.println();
}}

String call(String f) 
    throws UndefinedFunctionException :
{}
{{
    if(!returns.containsKey(f))
    {
        throw new UndefinedFunctionException(f);
    }
    insert ("CALL ", f);
    return returns.get(f);
}}

/**
 * Insert a attribution of a double variable.
 * @param var  Token of the variable
 * @param attr Token of the attribution  
 */
void attr(String var, String attr, String type) 
    throws WrongTypeException:
{ String s; }
{{
    s = actual + "::" + var;
    if(!scope.peek().containsKey(s))
        insert("ALOC ", "[", s, "]");
    scope.peek().put(s, type);
    switch(attr)
    {
        case "="  : break;
        case "+=" : checkTypeError(type);
                    insert("GET ", "[", s, "]"); 
                    insert("ADD"); 
                    break;
        
        case "-=" : checkTypeError(type);
                    insert("GET ", "[", s, "]"); 
                    insert("SWAP"); 
                    insert("SUB"); 
                    break;
                    
        case "*=" : checkTypeError(type);
                    insert("GET ", "[", s, "]"); 
                    insert("MUL"); 
                    break;
                    
        case "/=" : checkTypeError(type);
                    insert("GET ", "[", s, "]"); 
                    insert("SWAP");
                    insert("DIV"); 
                    break;
                    
        case "%=" : checkTypeError(type);
                    insert("GET ", "[", s, "]");
                    insert("SWAP");
                    insert("MOD"); 
                    break;
    } 
    
    insert("SET ", "[", s, "]"); insert("GET ", "[", s, "]");
}}

/**
 * Insert a GET for a variable.
 * @param var  Token of the variable
 */
String get(Token var) 
    throws WrongTypeException :
{ String s; }
{{
    s = actual + "::" + var.image;
    if(!scope.peek().containsKey(s))
    {
        scope.peek().put(s, "number");
        insert("ALOC ", "[", s, "]");
        insert("PUSH 0");
        insert("SET ", "[", s, "]");
    }
    insert("GET ", "[", s, "]");
    return scope.peek().get(s);
}}

/**
 * Auxiliar function - cmp.
 * @param  t Token with the comparison
 *           operator
 * @return String with comparison operator
 */
String cmp (Token t) :
{}
{{
    switch(t.image)
    {
        case "==": return "EQ";
        case "!=": return "NE";
        case "<" : return "LT";
        case "<=": return "LE";
        case ">=": return "GE";
        case ">" : return "GT";
        default  : return "\n"; // Invalid operator
    } 
}}

/**
 * Auxiliar function - sign.
 * @param  t Token with the sign
 * @return Sign of a term
 */
String sign (Token t) :
{}
{{
    return t.image.equals("+") ? "ADD" : "SUB"; 
}}

/**
 * Auxiliar function - op.
 * @param  t Token with the operation
 * @return Operation of a factor
 */
String op (Token t) :
{}
{{
    switch (t.image)
    {
        case "*": return "MUL";
        case "/": return "DIV";
        case "%": return "MOD";
     }   
    return t.image;
}}

/**
 * insert a additive inverse of a factor 
 * @param  t Token with the sign
 */
void unarySign (Token t) :
{}
{{
    if(t.image.equals("-"))
    {
        insert("PUSH -1");
        insert("MUL");
    } 
}}

/**
 * Auxiliar function - atof.
 * @param  t Token with a double
 * @return Double value of the token
 */
double atof(Token t) :
{}
{{    
    return Double.parseDouble(t.image);
}}

/**
 * Auxiliar function - say.<br>
 * Abbreviation of "System.out.println" 
 * with debugger purpouses.
 * @param o Object to be printed
 */
private void say(Object o) :
{
    String s;
}
{{
    s = (o == null)? "null" : o.toString();
    System.out.println(s);
}}

private void checkTypeError(String s)
    throws WrongTypeException :
{}
{{
    if (s != null)
        if(!s.equals("number"))
            throw new WrongTypeException("number");
            
}}
