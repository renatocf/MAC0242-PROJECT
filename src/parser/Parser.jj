/* adder.jj Adding up numbers */
options 
{
    STATIC    = false ;
    LOOKAHEAD = 3;
}
PARSER_BEGIN(Parser)

package parser;
import parser.*;
import java.util.HashMap;
import exception.WrongTypeException;

/**
 * <b>Parser for user Program<b>
 * @author Renato Cordeiro Ferreira
 * @author Vinicius Nascimento Silva
 */
public class Parser 
{
    HashMap<String,String> symbol = new HashMap<String,String>();
    
    public static void main( String[] args )
        throws ParseException, 
               TokenMgrError, 
               WrongTypeException 
    {
        Parser parser = new Parser(System.in);
        parser.Start(); 
    }
}

PARSER_END(Parser)

SKIP : { " " | "\n" | "\r" | "\r\n"}
TOKEN : {< LBRACE : "(" >}
TOKEN : {< RBRACE : ")" >}

TOKEN : {< NUMBER : (["0"-"9"])+  ("." (["0"-"9"])+)? >}
TOKEN : {< STRING : ( ("\"") (~["\""])* ("\"")) >}

TOKEN : {< SIGN : "+"  | "-"  >}
TOKEN : {< OP   : "*"  | "/" | "%" >}
TOKEN : {< CMP  : "==" | "!=" | "<" | "<=" | ">=" | ">" >}
TOKEN : {< ATTR : "="  | "+=" | "-=" | "*=" | "/=" | "%=" >}

TOKEN : {< WORD   : (["A"-"Z"] |  ["a"-"z"] | "_")+ >}

TOKEN : {< SIGIL  : "#" | "$" | "^" | "!" | "&" >}
TOKEN : {< DOUBLE : "#" <WORD> >}
TOKEN : {< VAR    : <SIGIL> <WORD> >}


TOKEN : {< EOL : ";" >}
/**
 * 
 * 
 * 
 */
 
/**
 * Defines program expressions.
 */ 
void Start() 
    throws WrongTypeException :
{
}    
{
    (
        (   
//            (
                expression()
                { insert("POP"); }
            //)
  //          |
    //        (
      //          stringAttribution()
        //    )
        )?
        <EOL>
        { say("--------------------------------"); }
    )*
}

void stringAttribution() :
{
    Token var, str;
}
{
    var = <WORD> <ATTR> 
    (
        str = <STRING>
        { attrString(var, str); }
    ) 
    |
    (str = <WORD>)
    
}

/**
 * Insert a attribution of a double variable.
 * @param var  Token of the variable
 * @param attr Token of the attribution  
 */
void attrString(Token var, Token str) :
{ String s; }
{{
    s = var.image;
    if(!symbol.containsKey(s))
    {
        symbol.put(s, "num");
        insert("ALOC ", "[", s, "]");
    }
    insert("PUSH ", str.image);
    insert("SET " , "[", s, "]");
    insert("GET " , "[", s, "]");
}}
    


/**
 * Expression is a comparison of Arit's.
 */
void expression() 
    throws WrongTypeException :
{
    Token   t;
}
{
    arit()
    (
        t = <CMP>            
        arit() 
        { insert(cmp(t)); }
    )*
}

/**
 * Arit is a sum of terms.
 */
void arit() 
    throws WrongTypeException :
{
    Token   t;
}
{
    term()
    (
        t = <SIGN>            
        term() 
        { insert(sign(t)); }
    )*
}

/**
 * Term is a product of elements.
 */
void term () 
    throws WrongTypeException :
{
    Token  t;
    double value;
}
{
    element()
    (
        t = <OP>
        element()
        
        { insert(op(t)); }
    )*
}

/**
 * Element is either a factor or a signed factor.
 */
void element() 
    throws WrongTypeException :
{
    Token t;
}
{
    factor()
    |
    (
        t = <SIGN>
        factor()
        { unarySign(t); }
    )    
}

/**
 * Factor is either a attribution, a variable, 
 * a number or a braced expression.
 */
void factor ()  
    throws WrongTypeException :
{
    Token t, v;
    double   value;
}
{    
    (
        t = <WORD> 
        v = <ATTR>
        expression()
        { attrDouble(t, v); }
    )
    |
    (
        t = <WORD> 
        v = <ATTR>
        <STRING>
        { say("funcionou"); }
    )
    |
        t = <WORD>
        { getDouble(t); }
    |
    (
        t = <NUMBER>
        { value = atof(t); }
        { PUSH(value);     }
    )
    |
    (
        <LBRACE> 
        expression()
        <RBRACE>
    )

}

/**
 * Auxiliar function for 
 * pushing in the assembly.
 * @param o Pushed object
 */
void PUSH(Object o) :
{}
{{    
    insert("PUSH ", o);
}}

/**
 * Print string representation of | "%"
 * a variable number of objects.
 * @param obj List of objects
 */
void insert(Object ... obj) :
{
    String s;
}
{{
    for(Object o: obj)
    {
        s = (o == null)? "null" : o.toString();
        System.out.print(s);
    }
    System.out.println();
}}

/**
 * Insert a attribution of a double variable.
 * @param var  Token of the variable
 * @param attr Token of the attribution  
 */
void attrDouble(Token var, Token attr) :
{ String s; }
{{
    s = var.image;
    if(!symbol.containsKey(s))
    {
        symbol.put(s, "num");
        insert("ALOC ", "[", s, "]");
    }
    switch(attr.image)
    {
        case "="  : break;
        case "+=" : insert("GET ", "[", s, "]"); 
                    insert("ADD"); 
                    break;
        
        case "-=" : insert("GET ", "[", s, "]");
                    insert("SWAP"); 
                    insert("SUB"); 
                    break;
                    
        case "*=" : insert("GET ", "[", s, "]"); 
                    insert("MUL"); 
                    break;
                    
        case "/=" : insert("GET ", "[", s, "]"); 
                    insert("SWAP");
                    insert("DIV"); 
                    break;
                    
        case "%=" : insert("GET ", "[", s, "]"); 
                    insert("SWAP");
                    insert("MOD"); 
                    break;
    } 
    
    insert("SET ", "[", s, "]"); insert("GET ", "[", s, "]");
}}

/**
 * Insert a GET for a double variable.
 * @param var  Token of the variable
 */
void getDouble(Token var) 
    throws WrongTypeException :
{ String s; }
{{
    s = var.image;
    if(!symbol.containsKey(s))
    {
        symbol.put(s, "num");
        insert("ALOC ", "[", s, "]");
        insert("PUSH 0");
        insert("SET ", "[", s, "]");
    }
    else
    {
        if(!symbol.get(s).equals("num"))
            throw new WrongTypeException("number");
    }
    insert("GET ", "[", s, "]");
}}

/**
 * Auxiliar function - cmp.
 * @param  t Token with the comparison
 *           operator
 * @return String with comparison operator
 */
String cmp (Token t) :
{}
{{
    switch(t.image)
    {
        case "==": return "EQ";
        case "!=": return "NE";
        case "<" : return "LT";
        case "<=": return "LE";
        case ">=": return "GE";
        case ">" : return "GT";
        default  : return "\n"; // Invalid operator
    } 
}}

/**
 * Auxiliar function - sign.
 * @param  t Token with the sign
 * @return Sign of a term
 */
String sign (Token t) :
{}
{{
    return t.image.equals("+") ? "ADD" : "SUB"; 
}}

/**
 * Auxiliar function - op.
 * @param  t Token with the operation
 * @return Operation of a factor
 */
String op (Token t) :
{}
{{
    switch (t.image)
    {
        case "*": return "MUL";
        case "/": return "DIV";
        case "%": return "MOD";
     }   
    return t.image;
}}

/**
 * insert a additive inverse of a factor 
 * @param  t Token with the sign
 */
void unarySign (Token t) :
{}
{{
    if(t.image.equals("-"))
    {
        insert("PUSH -1");
        insert("MUL");
    } 
}}

/**
 * Auxiliar function - atof.
 * @param  t Token with a double
 * @return Double value of the token
 */
double atof(Token t) :
{}
{{    
    return Double.parseDouble(t.image);
}}

/**
 * Auxiliar function - say.<br>
 * Abbreviation of "System.out.println" 
 * with debugger purpouses.
 * @param o Object to be printed
 */
private void say(Object o) :
{
    String s;
}
{{
    s = (o == null)? "null" : o.toString();
    System.out.println(s);
}}
