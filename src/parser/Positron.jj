options 
{
    STATIC    = true;
    LOOKAHEAD = 2;
}

PARSER_BEGIN(Positron)
/**********************************************************************/
/* Copyright 2013 KRV                                                 */
/*                                                                    */
/* Licensed under the Apache License, Version 2.0 (the "License");    */
/* you may not use this file except in compliance with the License.   */
/* You may obtain a copy of the License at                            */
/*                                                                    */
/*  http://www.apache.org/licenses/LICENSE-2.0                        */
/*                                                                    */
/* Unless required by applicable law or agreed to in writing,         */
/* software distributed under the License is distributed on an        */
/* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,       */
/* either express or implied.                                         */
/* See the License for the specific language governing permissions    */
/* and limitations under the License.                                 */
/**********************************************************************/
package parser.positron;

// Default libraries
import java.util.Stack;
import java.util.Vector;
import java.util.HashMap;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.ListIterator;
import java.lang.reflect.Field;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

// Libraries
import parser.*;
import stackable.*;
import stackable.item.*;
import robot.Command;
import robot.Returns;

// Exceptions
import exception.WrongTypeException;
import exception.MissingReturnException;
import exception.InvalidOperationException;
import exception.UndefinedFunctionException;

/**
 * <b>Parser for Positron Language<b>
 * @author Karina Suemi Awoki
 * @author Renato Cordeiro Ferreira
 * @author Vinicius Nascimento Silva
 */
public class Positron 
{
    // Variables
    private static int                                count;
    private static String                             actual;  
    private static String                             flow;
    private static ArrayList <String>                 magic;  
    private static Stack     <HashMap<String,String>> scope;   
    private static Stack     <Vector<Command>>        blocks;  
    private static HashMap   <String,String>          returns; 
    private static HashMap   <String,Parameters>      functions;
    
    // Auxiliar variables
    private static Variable BLOCK_FLAG = new Variable("BLOCK_FLAG");
    
    // Positron Parser
    private static Positron parser = null;
    
    /**
     * Positron - parse.<br>
     * Read from stdin and make a program 
     * accordingly to the input.
     * 
     * @return Vector with commands from
     *         readable by RVM
     * 
     * @throws TokenMgrError, 
     * @throws ParseException, 
     * @throws WrongTypeException,
     * @throws MissingReturnException,
     * @throws InvalidOperationException,
     * @throws UndefinedFunctionException
     */
    public static Vector<Command> parse()
        throws TokenMgrError, 
               ParseException, 
               WrongTypeException,
               MissingReturnException,
               InvalidOperationException,
               UndefinedFunctionException
    {
        Positron.Init();
        Positron.ReInit(System.in);
        return Positron.Start();
    }
    
    /**
     * Positron - parse.<br>
     * Read a file and translates the program 
     * in Positron to the RVM bytecode.
     * 
     * @param  path Path to file to be compiled
     * @return Vector with commands from
     *         readable by RVM
     * 
     * @throws TokenMgrError, 
     * @throws ParseException, 
     * @throws WrongTypeException,
     * @throws MissingReturnException,
     * @throws InvalidOperationException,
     * @throws UndefinedFunctionException
     */
    public static Vector<Command> parse(String path)
        throws ParseException, 
               TokenMgrError, 
               WrongTypeException,
               UndefinedFunctionException,
               MissingReturnException,
               InvalidOperationException
    {
        Vector<Command> main; 
        try {
            Positron.Init();
            
            InputStream is = parser.getClass().getResourceAsStream("/behaviors/stdlib.e");
            InputStreamReader file = new InputStreamReader(is);
            BufferedReader txtReader = new BufferedReader(file);           
                        
            // Header of stdlib
            Positron.ReInit(txtReader);
            main = Positron.Import("stdlib");
            
            if(main == null) System.out.println("ERROR: Impossible to open" + "/behaviors/stdlib.e");
            
            // Main program
            Positron.ReInit(new FileInputStream(path));
            main.addAll(Positron.Start());
            
            if(main == null) System.err.println("ERROR: Impossible to open" + path);
            
            is = parser.getClass().getResourceAsStream("/behaviors/stdlib.pos");
            file = new InputStreamReader(is);
            txtReader = new BufferedReader(file);
            
            // stdlib
            Positron.ReInit(txtReader);
            main.addAll(Positron.Import("stdlib"));
            
            if(main == null) System.out.println("ERROR: Impossible to open" + "/behaviors/stdlib.pos");
            // Add a final prog to identify 
            // when the 'file' is finished
            main.add(null);
            
            return main;
            
        } catch(/*FileNotFound*/Exception e) {
            System.err.println("[POSITRON] File not found!");
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * <b>Positron - Main</b><br>
     * Run the parser in an interactive 
     * mode, mainly with debug purposes.
     * 
     * @throws TokenMgrError, 
     * @throws ParseException, 
     * @throws WrongTypeException,
     * @throws MissingReturnException,
     * @throws InvalidOperationException,
     * @throws UndefinedFunctionException
     */
    public static void main( String[] args )
        throws ParseException, 
               TokenMgrError, 
               WrongTypeException,
               UndefinedFunctionException,
               MissingReturnException,
               InvalidOperationException
    {
        Vector<Command> prog = Positron.parse();
        
        // Print vector with the generated program
        int line = 1;
        for(Command cmd: prog)
            System.out.printf("%3d:  %s\n", line++, cmd);
    }
    
    /**
     * Positron - Init.<br>
     * Create a singleton parser. If it 
     * was already defined, do nothing.
     */
    private static void Init()
    {
        if(Positron.parser == null)
            Positron.parser = new Positron(System.in);
        
        Positron.count     = 1;
        Positron.magic     = new ArrayList <String>                 ();
        Positron.scope     = new Stack     <HashMap<String,String>> ();
        Positron.blocks    = new Stack     <Vector<Command>>        ();
        Positron.returns   = new HashMap   <String,String>          ();
        Positron.functions = new HashMap   <String,Parameters>      ();
    }
}

PARSER_END(Positron)

SKIP : { 
    " " | "\n" | "\r" | "\r\n" | "\t" 
    | <"//" (~["\n"])* "\n"> // C and C++ (or Java) style comments
    | <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

// Magic Variables
TOKEN : {< MAGIC  : "&"("ROBOT"|"BASE")     >}

// Pre-proc (One of these days)
TOKEN : {< IMPORT : "import" >}

// Dividers
TOKEN : {< LBRACE : "(" >}
TOKEN : {< RBRACE : ")" >}
TOKEN : {< LCURLY : "{" >}
TOKEN : {< RCURLY : "}" >}

// Types
TOKEN : {< TYPE : "way" | "number" | "string" | "void" | "coord" | "item" >}
TOKEN : {< SCOPE : "my" | "our" >}
TOKEN : {< NULL : "null" >}

// Syscalls
TOKEN : {< ASK    : "ask"      >}
TOKEN : {< HIT    : "hit"      >}
TOKEN : {< MOVE   : "move"     >}
TOKEN : {< FIRE   : "fire"     >}
TOKEN : {< LOOK   : "look"     >}
TOKEN : {< DRAG   : "drag"     >}
TOKEN : {< DROP   : "drop"     >}

// Auxiliar Methods
TOKEN : {< TOCOORD: "toCoord"   >}
TOKEN : {< TONUM_I: "toNumberI" >}
TOKEN : {< TONUM_J: "toNumberJ" >}

// IO
TOKEN : {< SAY    : "say"      >}
TOKEN : {< PRINT  : "print"    >}

// Loops
TOKEN : {< WHILE    : "while"    >}
TOKEN : {< BREAK    : "break"    >}
TOKEN : {< CONTINUE : "continue" >}

// Conditional
TOKEN : {< IF    : "if"     >}
TOKEN : {< ELSE  : "else"   >}
TOKEN : {< ELSIF : "elsif"  >}

// Functions
TOKEN : {< DEF   : "def"    >}
TOKEN : {< RET   : "return" >}

// Primitive types
TOKEN : {< ITEM     : "%"(["A"-"Z"] |  ["a"-"z"])+ >}
TOKEN : {< WAY      : "->" ( ( "N" | "S" ) ? ( "W" | "E" ) )? >}
TOKEN : {< NUMBER   : (["0"-"9"])+  ("." (["0"-"9"])+)? >}
TOKEN : {< STRING   : ( ("\"") (~["\""])* ("\"")) >}

// Operations
TOKEN : {< SIGN     : "+"  | "-"  >}
TOKEN : {< OP       : "*"  | "/" | "%" >}
TOKEN : {< CMP      : "==" | "!=" | "<" | "<=" | ">=" | ">" >}
TOKEN : {< ATTR     : "="  | "+=" | "-=" | "*=" | "/=" | "%=" >}
TOKEN : {< LOGICAL  : "&&" | "||" >}

// Variables
TOKEN : {< WORD   : (["A"-"Z"] |  ["a"-"z"] | "_")+ >}

// End of Line
TOKEN : {< EOL    : ";" >}
/**
 * 
 * 
 * 
 */

/**
 * Defines program expressions.
 */
Vector<Command> Start() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{
    HashMap<String,String> main   = new HashMap<String,String>();
    Iterator<String>       keys;
    Vector<Command> prog = new Vector<Command>();
}    
{
    {   
        blocks.push(prog);
        main.put("__SCOPE__", "main");
        scope.push(main);
        
        // Magic variables
        allocError();
        allocMagic();
        
        // Auxiliar variables
        insertArg("ALOC", BLOCK_FLAG);
        insertArg("PUSH", new Num(1));
        insertArg("SET" , BLOCK_FLAG);
    
        prog.addAll(Import("main"));
    
        // Free all the remaining variables;
        keys = scope.peek().keySet().iterator();
        while(keys.hasNext()) free(keys.next());
        
        insertLabel ("end");        

        // Free variables
        insertArg("FREE", BLOCK_FLAG);
        freeMagic();
        freeError();
        
        // Finish program
        insertCmd   ("END");
        
        return prog;;
    }
}

Vector<Command> Import(String namespace)
throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{
    Positron.flow      = namespace;
    Positron.actual    = namespace;
}
{
    {
        blocks.push(new Vector<Command>());
        scope.push(new HashMap<String,String>());
        scope.peek().put("__SCOPE__", namespace);
    }
    (
        (
                command()
            |
                prototype()
            |
                function()
            |
                <EOL>
        )
        { actual = namespace; }
        { flow   = namespace; }
    )*
    
    { return blocks.pop(); }
}


/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                              COMMANDS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

boolean command()
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{
    boolean returns = false;
}
{
    (
        (
            print()
            <EOL>
        )
        |
        (
            println()
            <EOL>
        )
        |
        returns = loop()
        |
        returns = conditional()
        |
        (
            expression()
            { insertCmd("POP"); }
            <EOL>
        )
    )
    { return returns; }
}

//* PRINT *************************************************************/
void print()
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{}
{
    <PRINT>
    (
        (
            <LBRACE>
            expression()
            { insertCmd("PRN"); }
            (
                ","
                expression()
                { insertCmd("PRN"); }
            )*
            <RBRACE>
        )
        |
        expression()
        { insertCmd("PRN"); }
        (
            ","
            expression()
            { insertCmd("PRN"); }
        )*
    )
}

//* SAY ***************************************************************/
void println()
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{}
{
    <SAY>
    (
        (
            <LBRACE>
            expression()
            { insertCmd("PRN"); }
            (
                ","
                expression()
                { insertCmd("PRN"); }
            )*
            <RBRACE>
        )
        |
        expression()
        { insertCmd("PRN"); }
        (
            ","
            expression()
            { insertCmd("PRN"); }
        )*
    )
    { 
        insertArg("PUSH", new Text("\n"));
        insertCmd("PRN"); 
    }
}

//* WHILE *************************************************************/
boolean loop()
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{
    String  s;
    String  oldFlow;
    Token   l;
    boolean returned = false;
}
{
    <WHILE>
    {
        oldFlow = flow;
        flow = "WHILE" + "_" + count++;
        insertLabel(flow);
        
        // Reset if flag
        insertArg("PUSH", new Num(1));
        insertArg("SET", BLOCK_FLAG);
    }
    <LBRACE>
    s = expression()
    (
        l = <LOGICAL>
        s = expression()
    )*
    <RBRACE>
    (
        (
            returned = block(null)
            { 
                // Go back to the top
                insertArg("GET", BLOCK_FLAG);
                insertArg("JIF", new Text(flow));
                
                flow = oldFlow;
                return returned; 
            }
        )
        |
        <EOL>
        { insertArg("JIT", new Text(flow)); }
    )
    { return false; }
}

//* IF-ELSIF-ELSE *****************************************************/
boolean conditional() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{
    String  s;
    String  oldFlow;
    Token   l;
    boolean returned = false;
}
{
    <IF>
    { 
        oldFlow = flow;
        flow = "IF" + "_" + count++; 
    }
    <LBRACE>
    s = expression()
    /*{ checkTypeError(s); }*/
    (
        l = <LOGICAL>
        s = expression()
        /*{ checkTypeError(s); }*/
        { insertCmd(logical(l)); }
    )*
    <RBRACE>
    returned = block(null) 
    (
        <ELSIF>
        <LBRACE>
        s = expression()
        /*{ checkTypeError(s); }*/
        (
            l = <LOGICAL>
            s = expression()
            /*{ checkTypeError(s); }*/
            { insertCmd(logical(l)); }
        )*
        <RBRACE>
        { insertArg("GET", BLOCK_FLAG); }
        { insertCmd("MUL");          }
        returned = block(null)
    )*
    (
        <ELSE>
        { insertArg("GET", BLOCK_FLAG); }
        returned = block(null)
    )?
     
    { 
        insertArg("PUSH", new Num(1));
        insertArg("SET", BLOCK_FLAG);
        
        flow = oldFlow;
        return returned; 
    }
}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                              SYSCALLS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

String syscall()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    String s;
}
{
    (
        s = drag()
        |
        s = drop()
        |
        s = look()
        |        
        s = ask()
        |
        s = fire()
        |
        s = hit()
        |
        s = move()
    )
    { return s; }
}

//* DRAG **************************************************************/
String drag()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{           
    <DRAG>
    (
        (
            <LBRACE>
            expression()
            { insertCmd("DRAG"); }
            <RBRACE>
        )
        |
        expression()
        { insertCmd("DRAG"); }
    )
    { return "number"; }
}
//* DROP **************************************************************/
String drop()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <DROP>
    (
        (
            <LBRACE>
            expression()
            { insertCmd("DROP"); }
            <RBRACE>
        )
        |
        expression()
        { insertCmd("DROP"); }
    )
    { return "number"; }
}

//* LOOK **************************************************************/

String look()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <LOOK>
    <LBRACE>
    {
        insertLabel("lookStart" + count);
        insertCmd("SEE");
        
        // Checking if SEE worked
        insertArg("PUSH", new Num(0));
        insertCmd("LE"  );
        insertArg("JIT" , new Num(9));
    }
        expression()
    {
        
        insertCmd("SEEK");
        
        // Checks if false 
        insertArg("STO" , new Num(0));
        insertArg("RCL" , new Num(0));
        insertArg("PUSH", new Num(0));
        insertCmd("EQ"  );
        insertArg("JIF" , new Num(3));
        insertArg("PUSH", Nil.get());
        insertArg("JMP" , new Num(13));
        
        // Store the coordinate
        insertArg("STO" , new Num(1));
        insertArg("RCL" , new Num(1));
        
        // Cleaning the Stack
        insertCmd("POP" );
        insertArg("RCL" , new Num(0));
        insertArg("PUSH", new Num(1));
        insertCmd("SUB"  );
        insertArg("STO" , new Num(0));
        insertArg("RCL" , new Num(0));
        insertArg("PUSH", new Num(0));
        insertCmd("EQ"  );
        insertArg("JIF" , new Num(-8));
        
        // Return the stored coordinate
        insertArg("RCL" , new Num(1));
        insertLabel("lookEnd" + count++);
    }
    <RBRACE>
    
    {return "number";}
}

//* ASK ***************************************************************/
String ask()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <ASK>
    (
        (
            <LBRACE>
            expression()
            { insertCmd("ASK"); }
            <RBRACE>
        )
        |
        expression()
        { insertCmd("ASK"); }
    )
    { return "coord"; }
}

//* ATTACKS ***********************************************************/
String hit()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <HIT>
    <LBRACE>
    expression()
    <RBRACE>
    { insertArg("PUSH", new Num(1));          }
    { insertArg("PUSH", new Attack("MELEE")); }
    { insertCmd("HIT");                       }
    { return "number";                        }
}

String fire()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <FIRE>
    <LBRACE>
    expression()
    <RBRACE>
    { insertArg("PUSH", new Attack("RANGED")); }
    { insertCmd("HIT");                        }
    { return "number";                         }
}

//* MOVE **************************************************************/
String move()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <MOVE>
    <LBRACE>
    expression()
    <RBRACE>
    { insertCmd("MOVE"); }
    { return "number";   }
}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                             FUNCTIONS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
ArrayList<String[]> header() 
    throws UndefinedFunctionException :
{
    Token t, f, s1, s2;
    Parameters parameter;
    String[] aux = new String[2];
    ArrayList<String[]> vars = new ArrayList<String[]>();
    ArrayList<String> types = new ArrayList<String>();
}
{
    t = <TYPE>
    f = <WORD>
    <LBRACE>
    (
        s1 = <TYPE>
        { types.add(s1.image); }
        { aux[0] = s1.image; }
        (
            s2 = <WORD>
            { aux[1] = s2.image; }
        )?
        {
            vars.add(aux);
            aux = new String[2];
        }
        (
            ","
            s1 = <TYPE>
            { types.add(s1.image); }
            { aux[0] = s1.image; }
            (
                s2 = <WORD>
                { aux[1] = s2.image; }
            )?
            {
                vars.add(aux);
                aux = new String[2];
            }
        )*
    )?
    <RBRACE>
    { parameter = new Parameters(types.toArray(new String[0])); }
    {   
        if (functions.containsKey(f.image))
        {
            if(functions.get(f.image).getSize() != parameter.getSize())
                throw new UndefinedFunctionException(f.image);
        }
        else        
            functions.put(f.image, parameter);
    }
    
    {   
        if (returns.containsKey(f.image))
        {
            if(!returns.get(f.image).equals(t.image))
                throw new UndefinedFunctionException(f.image);
        }
        else
            returns.put(f.image, t.image);                          
    }
        
    {
        actual = f.image;
        flow   = f.image; 
        return vars; 
    }
}


void prototype() 
    throws UndefinedFunctionException :
{}
{
    <DEF>
    header()
    <EOL>
}

void function() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{
    ArrayList<String[]> vars;
    boolean returned;
}
{
    vars = header()
    {
        insertArg("PUSH", new Num(0));
        insertLabel(actual);
    }
    returned = block(vars)
    {
        if(!returned && returns.get(actual) != null)
            throw new MissingReturnException(actual);
    }
}

boolean block(ArrayList<String[]> vars)
    throws WrongTypeException, 
           UndefinedFunctionException,
           MissingReturnException,
           InvalidOperationException :
{
    boolean returned = false;
    String s;
    Iterator<String> keys;
    Vector<Command>  code;
    Command mainJump = new Command("JIF", null, null);
    int dev;
}
{
    <LCURLY>
    {   
        scope.push(new HashMap<String,String>()); 
        scope.peek().put("__SCOPE__", flow);
        blocks.push(new Vector<Command>());
        blocks.peek().add(mainJump);
        if(vars != null)
            for(int i = vars.size() -1; i >= 0; i--)
            {
                if(vars.get(i)[0] == null || vars.get(i)[1] == null)
                    throw new UndefinedFunctionException(flow);
                attr(vars.get(i)[1], "=", vars.get(i)[0], "my");
                insertCmd("POP");
            }
    }
    (
        {
            if(returned)
                throw new InvalidOperationException("unreacheable code");
        }
        (
            <RET>
            s = expression()
            {
                if(!returns.get(actual).equals(s))
                    throw new WrongTypeException(returns.get(actual));
            }
            <EOL>
            { returned = true;}
        )
        |
        (
            command()
        )
    )*
    <RCURLY>
    
    { 
        keys = scope.peek().keySet().iterator();
        while(keys.hasNext())
            free(keys.next());
        scope.pop();
        
        insertArg("PUSH", new Num(0));
        insertArg("SET", BLOCK_FLAG);
        
        if (vars != null)
        {
            insertArg("PUSH", new Num(1));
            insertArg("SET", BLOCK_FLAG);
            insertCmd("RET");
        }
        dev = blocks.peek().size();
        mainJump.setAttribute(new Num(dev));
        code = blocks.pop();
        blocks.peek().addAll(code);
    }
    { return returned; }
}
/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                          AUXILIAR METHODS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

String auxMethods() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    String s;
}
{
    (
        s = toCoord()
        |
        s = toNumI()
        |
        s = toNumJ()
    )
    { return s; }
}

String toCoord()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <TOCOORD>
    <LBRACE>
    expression()
    { insertCmd("COOR"); }
    <RBRACE>
    {return "coord";}
}

String toNumI()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <TONUM_I>
    <LBRACE>
    expression()
    { insertCmd("GTIJ"); }
    { insertCmd("POP" ); }
    <RBRACE>
    {return "number";}
}

String toNumJ()
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{}
{
    <TONUM_J>
    <LBRACE>
    expression()
    { insertCmd("GTIJ"); }
    { insertCmd("SWAP"); }
    { insertCmd("POP" ); }
    <RBRACE>
    {return "number";}
}


/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                            EXPRESSIONS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
        
/**
 * Expression is a comparison of Arit's.
 */
String expression() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    Token   t;
    String s = "";
}
{
    s = arit()
    (
        t = <CMP>
        s = arit()
        { insertCmd(cmp(t)); }
    )*
    { return s; }
}

/**
 * Arit is a sum of terms.
 */
String arit() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    Token   t;
    String  s = "";
}
{
    s = term()
    (
        t = <SIGN>            
        { checkTypeError(s); }
        s = term() 
        { checkTypeError(s); }
        { insertCmd(sign(t)); }
    )*
    { return s; }
}

/**
 * Term is a product of elements.
 */
String term () 
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    Token  t;
    double value;
    String s = "";
}
{
    s = element()
    (
        t = <OP>
        { checkTypeError(s); }
        s = element()
        { checkTypeError(s); }
        { insertCmd(op(t)); }
    )*
    { return s; }
}

/**
 * Element is either a factor or a signed factor.
 */
String element() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    Token t;
    String s = "";;
}
{
    (s = factor()
    { return s; })
    |
    (
        t = <SIGN>
        s = factor()
        { checkTypeError(s); }
        { unarySign(t); }
        { return s; }
    )
    {return s;}
    
}

/**
 * Factor is either a attribution, a variable, 
 * a number or a braced expression.
 */
String factor ()  
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    Token t, u = null, v;
    double value;
    String s = "";
    int i = 0;
    Parameters p;
}
{ 
    (
        (
            (   
                u = <SCOPE>
            )?
            t = <WORD>
            (
                    v = <ATTR>
                    s = expression()
                    { attr(t.image, v.image, s, u != null ? u.image : null); }
            )
        )
        { return s; }
        |
        (
            t = <MAGIC>
            (
                    v = <ATTR>
                    s = expression()
                    { attrMagic(t.image, v.image, s); }
            )
        )
        { return s; }
    )
    |
    (
        t = <WORD>
        { 
            p = functions.get(t.image);
            if(p == null)
            {throw new UndefinedFunctionException(t.image);} 
        }
        <LBRACE>
        (
            s = expression()
            {
                if (i == p.getSize())
                    throw new UndefinedFunctionException(t.image);   
                if(!s.equals(p.getType(i++)))
                    throw new WrongTypeException(
                        p.getType(i-1) + " on argument " + i
                        + " at function '" + t.image + "'"
                    );
            } 
            (
                "," 
                s = expression()
                {
                    if (i == p.getSize())
                        throw new UndefinedFunctionException(t.image);
                    if(!s.equals(p.getType(i++)))
                       throw new WrongTypeException(
                        "at function '" + t.image + "': " 
                        + p.getType(i-1) + " on position " + i
                    );
                }
            )*
        )?
        {
            if (i != p.getSize())
                throw new UndefinedFunctionException(t.image);
        }
        <RBRACE>
        { s = call(t.image); }
        { return s; }
    )
    |
        t = <MAGIC>
        { getMagic(t.image); }
        { return "coord"; }
    |
        t = <WORD>
        { s = get(t.image); }
        { return s; }
    |
    (
        coord()
        { return "coord"; }
    )
    |
    (
        s = syscall()
        { return s; }
    )
    |
    (
        s = auxMethods()
        { return s; }
    )
    |
    (
        t = <ITEM>
        { pushItem(t.image.replaceFirst("%", "")); }
        { return "item";}                         
    )
    |
    (
        t = <WAY>
        { pushWay(t.image.replaceFirst("->", "")); }
        { return "way";                            }
    )
    |
        (
        t = <STRING>
        { pushString(t.image.replaceAll("\"", "")); }
        { return "string";                          }
    )
    |
    (
        t = <NUMBER>
        { value = atof(t);      }
        { pushNumber(value);    }
        { return "number";      }
    )
    |
        <NULL>
        { insertArg("PUSH", Nil.get()); }
        { return "number";              }
    |
    (
        <LBRACE> 
        s = expression()
        <RBRACE>
        { return s; }
    )
    
}

void coord() 
    throws WrongTypeException, 
           UndefinedFunctionException,
           InvalidOperationException :
{
    String s;
}
{
    "["
    s = expression()
    ","
    s = expression()
    "]"
    { insertCmd("COOR"); }
}

/**
 * Auxiliar function for 
 * pushing text in the assembly.
 * @param o Pushed text
 */
void pushString(String s) :
{}
{{    
    insertArg("PUSH", new Text(s));
}}

/**
 * Auxiliar function for pushing 
 * items in the assembly.
 * @param s Pushed item
 */
void pushItem(String s)
    throws InvalidOperationException :
{}
{{    
    switch (s.toUpperCase())
    {
        case "CRYSTAL" : insertArg("PUSH", new Crystal()); break;
        case "STONE"   : insertArg("PUSH", new Stone());   break;
        default        : throw new InvalidOperationException(s + " do not exists");
    }
}}

/**
 * Auxiliar function for pushing 
 * directions in the assembly.
 * @param s Pushed direction
 */
void pushWay(String s)
    throws InvalidOperationException :
{}
{{    
    insertArg("PUSH", new Direction(s));
}}

/**
 * Auxiliar function for 
 * pushing number in the assembly.
 * @param o Pushed number
 */
void pushNumber(double n) :
{}
{{    
    insertArg("PUSH", new Num(n));
}}

/**
 * Print string representation of | "%"
 * a variable number of objects.
 * @param obj List of objects
 */
void insert(String label, String cmd, Stackable arg) :
{}
{{
    blocks.peek().add(new Command(cmd, arg, label));
}}

void insertArg(String cmd, Stackable arg) :
{}
{{
    insert(null, cmd, arg);
    //say(cmd + " " + arg.toString());
}}

void insertCmd(String cmd) :
{}
{{
    insert(null, cmd, null);
    //say(cmd);
}}

void insertLabel(String label) :
{}
{{
    insert(label, null, null);
    //say(label + ":");
}}

String call(String f) 
    throws UndefinedFunctionException :
{}
{{
    if(!returns.containsKey(f))
    {
        throw new UndefinedFunctionException(f);
    }
    insertArg("PUSH", new Num(1));
    insertArg("CALL", new Text(f));
    return returns.get(f);
}}

/**
 * Insert a attribution of a variable.
 * @param var  Token of the variable
 * @param attr Token of the attribution  
 */
void attr(String var, String attr, String type, String sc) 
    throws WrongTypeException,
           InvalidOperationException :
{ String s; }
{{
    if (sc != null && sc.equals("my"))
    {
        if(!scope.peek().containsKey(var))
        {
            scope.peek().put(var, type);
            s = flow + "::" + var;
            insertArg("ALOC", new Variable(s));
        }
        else
            throw new InvalidOperationException("\"my\"");
    }
    else if (sc != null && sc.equals("our"))
    {
        if(!scope.get(0).containsKey(var))
        {
            scope.get(0).put(var, type);
            s = "main" + "::" + var;
            insertArg("ALOC", new Variable(s));
        }
        else
            throw new InvalidOperationException("\"our\"");
    }
    else // null
    {
        s = declared(var);
        if(s == null)
        {
            scope.get(0).put(var, type);
            s = "main" + "::" + var;
            insertArg("ALOC", new Variable(s));
        }
    }
    
    
    switch(attr)
    {
        case "="  : break;
        case "+=" : checkTypeError(type);
                    insertArg("GET", new Variable(s)); 
                    insertCmd("ADD"); 
                    break;
        
        case "-=" : checkTypeError(type);
                    insertArg("GET", new Variable(s)); 
                    insertCmd("SWAP"); 
                    insertCmd("SUB"); 
                    break;
                    
        case "*=" : checkTypeError(type);
                    insertArg("GET", new Variable(s)); 
                    insertCmd("MUL"); 
                    break;
                    
        case "/=" : checkTypeError(type);
                    insertArg("GET", new Variable(s)); 
                    insertCmd("SWAP");
                    insertCmd("DIV"); 
                    break;
                    
        case "%=" : checkTypeError(type);
                    insertArg("GET", new Variable(s));
                    insertCmd("SWAP");
                    insertCmd("MOD"); 
                    break;
    } 
    
    insertArg("SET", new Variable(s)); insertArg("GET", new Variable(s));
}}

/**
 * Insert a attribution of a magic variable.
 * @param var  Token of the variable
 * @param attr Token of the attribution  
 */
void attrMagic(String var, String attr, String type) 
    throws WrongTypeException,
           InvalidOperationException :
{}
{{
    switch(attr)
    {
        case "="  : break;
        case "+=" : checkTypeError(type);
                    insertArg("GET", new Variable(var)); 
                    insertCmd("ADD"); 
                    break;
        
        case "-=" : checkTypeError(type);
                    insertArg("GET", new Variable(var)); 
                    insertCmd("SWAP"); 
                    insertCmd("SUB"); 
                    break;
                    
        case "*=" : checkTypeError(type);
                    insertArg("GET", new Variable(var)); 
                    insertCmd("MUL"); 
                    break;
                    
        case "/=" : checkTypeError(type);
                    insertArg("GET", new Variable(var)); 
                    insertCmd("SWAP");
                    insertCmd("DIV"); 
                    break;
                    
        case "%=" : checkTypeError(type);
                    insertArg("GET", new Variable(var));
                    insertCmd("SWAP");
                    insertCmd("MOD"); 
                    break;
    } 
    
    insertArg("SET", new Variable(var)); insertArg("GET", new Variable(var));
}}


/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                  AUXILIAR FUNCTIONS - ERROR VARS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

/**
 * Auxiliar function to alloc error variables.
 */
void allocError() :
{}
{{
    insertLabel("error_variables");
    
    for(Returns r: Returns.values())
    {
        Variable name = new Variable("_" + r);
        insertArg("ALOC", name);
        insertArg("PUSH", new Num(r.getValue()));
        insertArg("SET", name);
    }
}}

/**
 * Auxiliar function to free the magic variables.
 */
void freeError() :
{}
{{
    for(Returns r: Returns.values())
        insertArg("FREE", new Variable("_" + r));
}}

/**
 * Insert a GET for an error variable.
 * @param var String with the name of the variable
 */
void getError(String var) 
    throws WrongTypeException :
{}
{{
    insertArg("GET", new Variable(var));
}}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                  AUXILIAR FUNCTIONS - MAGIC VARS
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

/**
 * Auxiliar function to alloc magic variables.
 */
void allocMagic() :
{}
{{
    magic.add("&ROBOT");
    magic.add("&BASE");
    
    insertLabel("magic_variables");
    for(String var: magic)
        insertArg("ALOC", new Variable(var));
}}

/**
 * Auxiliar function to free the magic variables.
 */
void freeMagic() :
{}
{{
    for(String var: magic)
        insertArg("FREE", new Variable(var));
}}

/**
 * Insert a GET for a magic variable.
 * @param var String with the name of the variable
 */
void getMagic(String var) 
    throws WrongTypeException :
{}
{{
    insertArg("GET", new Variable(var));
}}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                   AUXILIAR FUNCTIONS - VARIABLES
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

/**
 * Insert a GET for a variable.
 * @param var  Token of the variable
 */
String get(String var) 
    throws WrongTypeException :
{ String s; }
{{
    s = declared(var);
    if(s == null)
    {
        scope.get(0).put(var, "number");
        s = "main" + "::" + var;
        insertArg("ALOC", new Variable(s));
        pushNumber(0);
        insertArg("SET", new Variable(s));
    }
    insertArg("GET", new Variable(s));
    return typeof(var);
}}

void free(String s) :
{}
{{
    if(s.charAt(0) != '_' || s.charAt(1) != '_')
        insertArg("FREE", new Variable(flow + "::" + s));
}}

String declared(String var) :
{
    ListIterator<HashMap<String, String>> i;
    HashMap<String, String> varList;
    int size;
}
{{
    size = scope.size();
    i = scope.listIterator(size);
    
    while(i.hasPrevious())
    {
        varList = i.previous();
        if(varList.containsKey(var))
            return varList.get("__SCOPE__") + "::" + var;
    }
    return null;
}}

String typeof(String var) :
{
    ListIterator<HashMap<String, String>> i;
    HashMap<String, String> varList;
    int size;
}
{{
    size = scope.size();
    i = scope.listIterator(size);
    
    while(i.hasPrevious())
    {
        varList = i.previous();
        if(varList.containsKey(var))
            return varList.get(var);
    }
    return null;
}}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                   AUXILIAR FUNCTIONS - ARITHMETIC
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

/**
 * Auxiliar function - sign.
 * @param  t Token with the sign
 * @return Sign of a term
 */
String logical(Token t) :
{}
{{
    return t.image.equals("&&") ? "MUL" : "ADD"; 
}}

/**
 * Auxiliar function - cmp.
 * @param  t Token with the comparison
 *           operator
 * @return String with comparison operator
 */
String cmp (Token t) :
{}
{{
    switch(t.image)
    {
        case "==": return "EQ";
        case "!=": return "NE";
        case "<" : return "LT";
        case "<=": return "LE";
        case ">=": return "GE";
        case ">" : return "GT";
        default  : return "\n"; // Invalid operator
    } 
}}

/**
 * Auxiliar function - sign.
 * @param  t Token with the sign
 * @return Sign of a term
 */
String sign (Token t) :
{}
{{
    return t.image.equals("+") ? "ADD" : "SUB"; 
}}

/**
 * Auxiliar function - op.
 * @param  t Token with the operation
 * @return Operation of a factor
 */
String op (Token t) :
{}
{{
    switch (t.image)
    {
        case "*": return "MUL";
        case "/": return "DIV";
        case "%": return "MOD";
     }   
    return t.image;
}}

/**
 * insert a additive inverse of a factor 
 * @param  t Token with the sign
 */
void unarySign (Token t) :
{}
{{
    if(t.image.equals("-"))
    {
        insertArg("PUSH", new Num(-1));
        insertCmd("MUL");
    } 
}}

/**
 * Auxiliar function - atof.
 * @param  t Token with a double
 * @return Double value of the token
 */
double atof(Token t) :
{}
{{    
    return Double.parseDouble(t.image);
}}

/*
////////////////////////////////////////////////////////////////////////
-----------------------------------------------------------------------
                     AUXILIAR FUNCTIONS - DEBUG
-----------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

/**
 * Auxiliar function - say.<br>
 * Abbreviation of "System.out.println" 
 * with debugger purpouses.
 * @param o Object to be printed
 */
private void say(Object o) :
{
    String s;
}
{{
    s = (o == null)? "null" : o.toString();
    System.out.println(s);
}}

private void checkTypeError(String s)
    throws WrongTypeException :
{}
{{
    if (s != null)
        if(!s.equals("number") && !s.equals("coord"))
            throw new WrongTypeException("number or coord");
            
}}
