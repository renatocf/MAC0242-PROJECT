\documentclass[a4paper]{article}

% Linguagem
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}

% Pacotes matemáticos
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

% Fontes e identaçãp
\usepackage{setspace}                   % espaçamento flexível
\usepackage{indentfirst}                % indentação do primeiro parágrafo
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

% Pacotes para cores e modelos
\usepackage[a4paper,top=3.0cm,bottom=2.0cm,left=3.0cm,right=2.0cm]{geometry} \usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,
            colorlinks=true,citecolor=DarkGreen,linkcolor=DarkRed,
            urlcolor=DarkRed,filecolor=DarkGreen,
            bookmarksopen=true]{hyperref}

% Pacotes para itens
\usepackage{calc}  
\usepackage{enumitem}  

\title  {Projeto de Laboratório de Programação II - Fase 3}
\author {Karina Suemi, Vinícius Silva, Renato Cordeiro}
\date   {}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Introdução} \label{sec:introdução}

    Nesta fase, o projeto consiste em representar o jogo em ambiente
    gráfico usando bibliotecas já prontas do JAVA para conseguir 
    tais efeitos. 
    Assim, a arena e seus terrenos em formas hexagonais, os cristais, 
    os robôs, as pedras, as árvores e os diferentes tipos de cenários
    podem ser visualizados. Na fase anterior, foram criados diferentes
    tipos de climas, que acarretam no aparecimento de diversos cenários
    distintos.
    
    Há também a parte do sistema, onde damos características fixas aos 
    robôs (como vida e energia), criamos cristais aleatóriamente e 
    damos a opção de "desligar" ou "ligar" um robô, de modo que este 
    possa ser paralizado quando não tiver mais vidas.
    
    
    \subsection{Projeto}
    
    Os arquivos estão separados de acordo comcolor a seguinte estrutura de
    diretórios:
    \begin{itemize}
        \item \textbf{bin:}       Arquivo executável principal do programa;
        \item \textbf{behaviors:} Onde estão os programas teste em assembly
        						  do robô.
        \item \textbf{doc:}       Pasta para a documentação, com este arquivo 
                                  e a versão fonte em \LaTeX;
        \item \textbf{lib:}       Arquivos com classes/pacotes de Perl 
                                  no formato \texttt{.pm};
        \item \textbf{src:}       Pasta que contém os cógigos-fonte em JAVA,
        					      separados e organizados por pastas.
        \item \textbf{test:}      Arquivos de teste com código em Assembly
                                  do montador/máquina virtual \texttt{.txt}.
    \end{itemize}
    
    \subsection{Estrutura}
      
        Para informações sobre o uso de programa e os seus 
        desenvolvedores, consultar os arquivos \href{run:../README.md}
        {\texttt{README.md}} e \href{run:../LICENSE}{\texttt{LICENSE}}.
    

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Montador} \label{sec:montador}

    O montador tem como função ler o programa em texto (que será 
    passado pelo usuário), ver se ele está formatado de maneira 
    correta e em caso positivo, é criada uma matriz 3 x n, sendo $n$ 
    o número de comandos, que será passada para a Máquina Virtual.
    
    O arquivo com o montador está no diretório de bibliotecas 
    \texttt{lib/} e é chamado \href{run:../lib/Cortex.pm}
    {\texttt{Cortex.pm}}
    
    \bigskip\bigskip
    
    No caso, as linhas do programa de entrada terão que seguir o 
    seguinte padrão:

    \begin{center}
        \textbf{[ Comando, Argumento, Label ]}
    \end{center}
    
    O montador devolverá erro em caso de comandos que não sejam 
    compatíveis com seus respectivos tipos de argumentos. No caso da
    entrada ser: 
    
    \begin{description}
    %[leftmargin=!,labelwidth=\widthof{\bfseries The longest label}]

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        \item [\textbf{\textcolor{red}{x}} "ADD Olá"] 
        O comando ADD não deveria receber argumentos, e como não é o 
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "ADD"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "PUSH Oie!"] 
        O comando PUSH deveria receber argumentos numéricos, e como não é 
        o caso, o programa passará \emph{undef} para a Máquina Virtual.
    
        \item [\textcolor{green}{\checkmark} "PUSH 100"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "JIF 5uvas"] 
        O comando JIF deveria receber argumentos em forma de texto (pode
        conter números, desde que não sejam 1º caracter), e como não é o
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "JIF uvas5"] 
        Este seria o correto.

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \end{description}

    \bigskip\bigskip

    Segue a tabela com os argumentos necessários para cada tipo de 
    comando:
    
    \begin{center}
      \begin{tabular}{|c|l|rc|}
                        &  ADD - DIV - DUP - END - EQ - GE - GT   \\
          Vazio         &  MOD - LE - LT - MUL - NE - POP - PRN   \\
                        &  SUB - RET - MOVE - DRAG - DROP - HIT   \\
                        &  LOOK - ITEM - SEE - SEEK - ASK - NOP   \\
                        &  SWAP                                   \\
                        &                                         \\
          Numérico      &  RCL - STO                              \\
          			    &                                         \\
          Endereço      &  JMP - JIF - JIT - CALL                 \\
          			    &                                         \\
          Nome Variável &  ALOC - FREE - GET - SET                \\
                        &                                         \\
          String        &  JMP - JIF - JIT - CALL                 \\
          			    &                                         \\
          Empilhável    &  crystal - stone                        \\
                        &                                         \\
          Ataque        &  ranged - melee                         \\
                        
      \end{tabular}
    \end{center}
    
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Packages}
	Foram criados pacotes para facilitar a divisão
	e entendimento do código.
	
	\subsection{Arena}
		O package "Arena" cuida das classes que envolvem os
		terrenos e a arena em si, bem como o classe que cuida
		da autorização de execução de determinadas funções que
		necessitam da consultoria da arena para serem executadas.
		
		\subsubsection{ Action.java }
		    Aqui é onde encontramos a implementação das funções
		    utilizadas diretamente pelos robôs, tais como 
		    
		    {\textcolor{NavyBlue}{HIT} 
		    -- bate em outro robô -- 
		   
		    {\textcolor{NavyBlue}{ASK}
		    -- Devolve a sua localização --
		   
		    {\textcolor{NavyBlue}{SEE}
		    -- Observa a presença de algo na sua vizinhança --
		    
		    {\textcolor{NavyBlue}{SKIP}
		    -- Não faz nada --
		    		    
		    {\textcolor{NavyBlue}{SEND} 
		    -- manda mensagem para todos os robôs --
		    
		    {\textcolor{NavyBlue}{DROP}
		    -- Deposita itens (cristal) --
		    
		    {\textcolor{NavyBlue}{LOOK}
		    -- Observa a presença de algo em determina posição --
		    		    		    
		    {\textcolor{NavyBlue}{DRAG}
		    -- Pegar itens (cristal) --
		    
		    {\textcolor{NavyBlue}{MOVE}
		    -- Move para determinada direção --

		    \bigskip
		    
		    e tratamos a saída de modo que os dados que sejam 
		    emitidos na pilha ao usar a função, são devolvidos em
		    um vetor de Stackables. 
		    Caso a função só lance uma String como saída, essa 
		    String será passada para tipo Text e preencherá a 
		    primeira casa do vetor de Stackables.
		    
		    O restante das funções são auxiliares, que devolvem
		    os respectivos resultados de cada função
		    
		\subsubsection{ Appearence.java }
		    É uma estrutura chamada Enum, onde dizemos que as
		    aparências podem ser somente as mostradas a seguir:
		    {\textcolor{NavyBlue}{DEEP},
		    {\textcolor{NavyBlue}{DIRT},
            {\textcolor{NavyBlue}{GRASS},
            {\textcolor{NavyBlue}{ROCKY},
            {\textcolor{NavyBlue}{ICE},
            {\textcolor{NavyBlue}{WATER},
            {\textcolor{NavyBlue}{SAND},
            {\textcolor{NavyBlue}{JUNGLE} e
            {\textcolor{NavyBlue}{TUNDRA}.
		
		\subsubsection{ Map.java }
		    A classe mapa vai cuidar da matriz de terrenos, e 
		    podemos assumir que cada mapa terá um clima diferente.
		    
		    É nessa classe que também criamos os times a partir
		    do parâmetro número do time passado, onde temos uma 
		    matriz representando jogadores de determinado time.
		    
		    Também inserimos exércitos e removemos Scenários.
		    Como nas seguintes funções:
		    
		    {\textcolor{NavyBlue}{public Scenario
		    removeScenario(int i, int j)}
		    que eliminará os Scenários do terreno com as coordenadas
		    passadas como parâmetro. Essa função serve para o caso 
		    de termos ataque a árvores e até mesmo a morte de robôs,
		    já que estes também são do tipo Scenario.
		    
		    {\textcolor{NavyBlue}{public Robot insertArmy(String
		    name, int player, int ID, int i, int j, String pathToProg)}
            que irá inserir um robô de acordo com os parâmetros
            recebidos, como nome do robô, a qual jogador ele pertence,
            o seu ID e as suas coordenadas.
            Essa função irá criar esse robô e implementá-lo no como 
            um Scenario nas coordenadas indicadas da arena.

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		    
		\subsubsection{ Robot.java }
			Essa classe é a que define as características dos robôs
			em geral, como velocidade do robô, vida, quantos danos ele
			causa, entre outras.
			
			Dentre suas funções, temos o construtor que recebe determinadas
			características e cria um robô, têm também a
			 
			{\textcolor{NavyBlue}{public Item removeSlots(int position)}
			que remove o robô de determinado terreno, a
			
			{\textcolor{NavyBlue}{public void identify()}
			que imprime as características principais do robô,
			
			{\textcolor{NavyBlue}{public void run()}
			executa o programa, acrescentando 1 no PC,
			
			{\textcolor{NavyBlue}{public void upload(Vector<Command> PROG)}
			carrega um novo programa e 
			
			{\textcolor{NavyBlue}{public int takeDamage(int damage)}
			que, por ser um Scenario, remove das vidas do robô o dano 
			sofrido.
			
			E quando imprimimos um determinado robô, é devolvida uma
			String com o nome dele. Além de possuir também os getters
			e setters de determinadas características.
			
		
		\subsubsection{ RobotList.java }
			Ele cuida dos exércitos de robôs de tal forma
			a possuir um vetor de robôs e conseguir controlar
			seus movimentos e suas respectivas ordens.
			
			Para que possamos fazer com que os robôs mais velozes
			cheguem antes dos menos velozes, usamos a função quick 
			sort que compara velocidades de robôs, onde esta 
			ordenará a velocidade dos respectivos robôs e passará 
			para o programa, a ordem certa de movimentação.
			
			Funções como a de manutenção dos exércitos também são
			encontradas nessa classe, como a de adição e remoção
			de um robô dentro de determinado exército.
		
		\subsubsection{ Terrain.java }
		    Cada terrain é um empilhável e possui um tipo de 
		    rugosidade, uma aparência e possivelmente um
		    Scenario.
		    
		    A maioria de suas funções, além do construtor ( que
		    irá receber a aparência e a partir dela, determinar 
		    o tipo de rugosidade ), tem-se basicamente getters,
		    setters e removedores de características da classe.
		    É válido lembrar que utilizamos polimorfismo para o
		    cnstrutor dessa classe, pois há vários tipos dessa
		    função que recebem diferentes tipos e números de
		    argumentos.
		    
		
		\subsubsection{ Type.java }
		    Assim como em Appearence, type também é um Enum, só
		    que dessa vez, representa os tipos de terreno da
		    arena. Sendo eles, por enquanto:
		    {\textcolor{NavyBlue}{NORMAL} e 
            {\textcolor{NavyBlue}{ROUGH}.
		
		\subsubsection{ World.java }				
			World é uma parte mais global do programa que cuida das 
			características do jogo em geral, como número de 
			jogadores, tempo, o mapa, entre outros.
			É uma classe única, já que só teremos um único mundo
			para cada partida.
			
			Nela temos as funções que controlam a inserção e 
			remoção de exércitos, além da função que controla os
			timesteps (tempos ) e também cuisa do modo Debugger.
		
		
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
		
				
	\subsection{Exception}
		O package "Exception" cuida dos lançamentos de exceção
		que o programa gera para erros no código que será recebido
		do usuário.

		Como por exemplo as exceções de falha de segmentação,
		operações inválidas, erros de tipo, variáveis não
		inicializadas, entre outros.
		
		As classes desse package são chamadas pelas outras classes
		que utilizam essa forma de mandar exceção.

\bigskip
\bigskip
\bigskip
\bigskip 
		
	\subsection{Main}
        O package main contém a classe de mesmo nome, com o método
        main como principal. Esta classe é a responsável por receber
        informações do usuário, via linha de comando, e processá-los.

        Também nela, está o loop principal de executção dos 
        \emph{timesteps} da arena. Por padrão, o programa para de
        executar após 370 \emph{timesteps}.

        Para receber as opções, a classe Main utiliza duas bibliotecas
        externas, cujo download é realizado pelo programa Ivy dentro 
        do Ant. Ambas as bibliotecas são distribuídas com a licensa
        GNU GLP v3.0, e são o porte para Java da biblioteca getopt
        do C.
      
\bigskip
\bigskip
\bigskip
\bigskip	
	
	\subsection{Parameters}
		\subsubsection{ Debugger.java }
			Essa classe irá auxiliar no encontro dos erros do cógigo,
			pois mostra passo a passo, como o programa do usuário
			está sendo lido e interpretado.
			
		\subsubsection{ Game.java     }
		    É uma classe que detém as características do jogo 
		    que serão passadas para muitas outras classes.
		    Tais como a velocidade da animação, o tamanho do mapa,
		    o número máximo de robôs, entre outras.
		    
		    Ela foi criada para ter um maior controle das 
		    características configuracionais do jogo e caso
		    necessitem ser alteradas, todas estarão no mesmo lugar.
		    
        \subsubsection{ Costs.java    }
            É uma classe que contém as características dos robôs 
            relativas aos custos (energia que um robô irá gastar
            ou receber para determinado tipo de operação) tais como
            o quanto ele receberá por rodada e a energia baixa, média
            e alta que o robô gasta.
            Essas características são facilmente modificadas, pois 
            estão agrupadas no mesmo lugar.
            
        \subsubsection{ Verbosity.java }
            É um dos métodos debug, que usa a função de impressão
            na tela.


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
	\subsection{Parser}
		\subsubsection{ Parser.java }
		    Os parser em Perl recebe um vetor de trincas (comando,
            argumento, label), analisa as variáveis conforme o tipo
            correspondente no java e monta uma classe com o mesmo nome 
            do programa em assembly passado como argumento.
		    
		    Adicionalmente, o programa cria um arquivo "Parser.xml"
		    para ser rodado pelo Ant e compilar todos os códigos no
		    diretório do package.

            Estes parsers criados, então, ficam armazenados como 
            parte do package Parser.			
     
\bigskip
\bigskip
\bigskip
\bigskip	

    \subsection{Players}
        \subsubsection{ Player.java }
            Essa classe é responsável pelas características e funções
            relacionadas aos jogadores (ao time).
            No caso, cada jogador ou time terá um nome, uma base e
            uma cor de robôs, além das funções de adição e remoção de 
            um robô ao time e getters das informações desse jogador.
            
        \subsubsection{ Base.java }
            Representa as bases em si.
            Cada base, contendo características como posição, número
            de cristais e o jogador a que ela pertence.
            Possui as funções de acrescentar cristais, receber dano
            (que no caso, não faz nada, pois ao ser atacada a base não
            perde vidas) e getters das informações da base.
            
            A base tem um número escolhido ao acaso (42) de vidas,
            portanto, quando formos retornar o HP, sempre será 42. Já
            que a base, ao ser atacada, não recebe danos.
            
		    E ao imprimirmos uma base, teremos como resultado
		    "(ß) Base".
                   			
                   			
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Random}
	    Aqui criamos os mapas de determinados cenários,
	    gerados de forma probabilística, de modo que
	    o mesmo cenário se altere de acordo com a semente
	    passada. Cada cenário usa os tipos Scenario que são
	    os elementos que compõe os cenários.
	    
		\subsubsection{ CalmField.java }
		    Gera um cenário com árvores, rochas, pedras e 
		    cristais no terreno de forma probabilística.
		    Não podemos esquecer que ela gera as bases
		    necessárias para cada time.
		    
		\subsubsection{ Desert.java }
		    Gera um cenário com rochas, pedras, cristais e
		    bases de uma forma aleatoriezada e tenha as
		    características de um deserto.
		    
		\subsubsection{ Jungle.java }
		    Gera um cenário com árvores, rochas, pedras,
		    cristais e bases. Também possui um rio gerado
		    e distribuido probabilisticamente em meio a 
		    arena. 
		    
		    Esse rio possui partes de água mais rasas
		    e outras mais profundas, são as chamadas
		    deep water e water respectivamente.
		
		\subsubsection{ RamdomMap.java }
    		É responsável pela geração do mapa. Recebe 
    		parâmetros indicando qual será o tipo de
    		clima e os associa com o respectivo tipo
    		de mapa.
    		
    		Em sua outra função, ela gera o mapa, colocando
    		os determinados símbolos nos seus terrenos.
    		
		\subsubsection{ Theme.java }
		    Essa é uma interface que padroniza todos os 
		    tipos de temas, como JUNGLE, DESERT e WINTER.
		    Esse tipo de dado possui uma função específica
		    que retorna uma matriz representando o mapa
		    criado. 
		
		\subsubsection{ Weather.java }						
		    Weather é um tipo enum, representando os diversos,
		    tipos de cenário disponíveis para a arena. São eles:
		    
		    {\textcolor{NavyBlue}{CONTINENTAL},
            {\textcolor{NavyBlue}{ARTICAL},
            {\textcolor{NavyBlue}{DESERTIC} e
            {\textcolor{NavyBlue}{TROPICAL}.
		
		\subsubsection{ Winter.java }
		    Gera um cenário com árvores, rochas, pedras, 
		    cristais e bases de forma aleatória. Além de
		    gerar um rio congelado (água) no centro da arena.
		    

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		 
	\subsection{Remote}
		\subsubsection{ Operation.java }
			Essa classe é um meio de comunicação entre a arena e a RVM,
			pois ela manda como retorno a resposta da função, se ela pode
			ou não pode ser realizada.
			
			Para a sua construção, ela necessita receber a RVM, juntamente
			com a ação que o robô deseja realizar.

\bigskip
\bigskip
\bigskip
\bigskip 			

	\subsection{Robot}
	    Esse package cuida das funções atreladas aos robôs em
 	    si, entre elas está a RVM e as funções que interpretam
	    os comandos utilizados pelos usuários.
	    
		\subsubsection{ Arit.java }
		    Essa classe controla as funções que interpretam
		    os comandos aritméticos que o usuário passar na
		    pilha de comandos, como por exemplo: Soma,
		    subtração, divisão, Multiplicação e Resto.
		    Tudo isso é manipulado na pilha de dados,
		    recebemos os valores de lá, e mandamos a resposta
		    para o topo da mesma.
		    
		    Temos a seguinte função:
		    
		    {\textcolor{NavyBlue}{ private static final void 
		    calculate(RVM rvm, Operation op) }
		    que cuida da generalização do trabalho realizado 
		    na pilhaEssa classe controla as funções que interpretam
		    os comandos aritméticos que o usuário passar na
		    pilha de comandos, como por exemplo: 
		    {\textcolor{NavyBlue}{ADD} ( Soma ),
		    {\textcolor{NavyBlue}{SUB} ( Subtração),
		    {\textcolor{NavyBlue}{DIV} ( Divisão ), 
		    {\textcolor{NavyBlue}{MUL} ( Multiplicação ) e 
		    {\textcolor{NavyBlue}{MOD} ( Resto ).
		    Tudo isso é manipulado na pilha de dados,
		    recebemos os valores de lá, e mandamos a resposta
		    para o topo da mesma. de dados pelas funções aritméticas.
		
		\subsubsection{ Cast.java }
		    Essa classe está ligada ao tipo de variável que se refere
		    a coordenadas. 
		    Como coordenadas são a junção de 2 números, um I e um J,
		    essa classe possui funções que:
		    
		    {\textcolor{NavyBlue}{static void COOR(RVM rvm)}}
		    que pega dois Stackables da pilha que sejam do tipo Num
		    e os transforma em uma coordenada, empilhando esta na pilha
		    em forma de coordenada.
		    Ela desempilha antes o J e depois o I, portanto, na pilha,
		    para que essa função seja usada corretamente, o J deve estar
		    acima do I.
		    
		    {\textcolor{NavyBlue}{static void GTIJ(RVM rvm)}}
		    que pega um Stackable da pilha que seja do tipo coordenada
		    e o tranforma em dois números do tipo Num, jogando-os no
		    topo dessa mesma pilha.
		    Ele coloca primeiro o I e depois o J, de forma que o J fique
		    acima do I na pilha.
		    
		        
		\subsubsection{ Check.java }
		    Essa função tem como objetivo checar o terreno em
		    si e sua visinhança, bem como 
		    
		    {\textcolor{NavyBlue}{  static void ITEM(RVM rvm) }
		    que dá um pop na pilha caso o topo seja um terreno
		    e empilha os itens contidos nesse terreno na pilha
		    de dados.
		    
		    {\textcolor{NavyBlue}{  static void SEEK(RVM rvm) }
		    que verifica se o topo é um Stackable e desempilha
		    , depois verifica se o topo é um Around, e desempilha.
		    Depois, percorre a visinhança do próprio robô 
		    (que dependerá do quão longe o robô enxerga)
		    e tenta encontrar Items nessa visinhança.
		    
		    Isso auxilia quando o robô for procurar cristais,
		    por exemplo, fazendo com que ele não precise estar
		    necessariamente na casa do cristal para notar a 
		    sua presença.
		    
		\subsubsection{ Command.java }
		    Cria objetos do tipo comando, para serem manipulados
		    da mesma forma na pilha de comandos.
		    Tem como parâmetros o próprio comando, os argumentos
		    do tipo Stackable e a label que caracterizam as linhas
		    passadas pelo usuário no programa que o mesmo cria em
		    baixo nível.
		    Na classe, também temos as funções básicas getters e
		    setters de determinadas características de cada
		    comando.
		    
		\subsubsection{ Ctrl.java }
		    É um comunicador que interpreta um comando do programa
		    do usuário em forma de String (por exemplo: "JMP") e 
		    chama a respectiva função, passando os seus parâmetros 
		    para ela.
		    
		    Dentre esses comandos que ela interpreta, estão também
		    aqueles que podem ser executados pelos robôs, como
		    {\textcolor{NavyBlue}{MOVE}, 
		    {\textcolor{NavyBlue}{HIT}, 
		    {\textcolor{NavyBlue}{DRAG}, 
		    {\textcolor{NavyBlue}{DROP}, 
		    {\textcolor{NavyBlue}{SEE} e 
		    {\textcolor{NavyBlue}{LOOK}.
		
		\subsubsection{ Debug.java }
		    Essa clase é responsável por captar os erros coletados na
		    RVM, os erros dos programas em assembly.
		    Ela possui funções que imprimem onde o erro ocorreu, os 
		    comandos executas, e a situação da pilha de dados em cada
		    comando. E isso é feito de forma colorida para facilitar o
		    encontro de erros do programa.
		    
		\subsubsection{ Func.java }
		    É responsável pelas funções CALL e RET que controlam
		    o valor do PC quando comandos do tipo Jump são
		    executados.
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ static void CALL(RVM rvm, 
		    Stackable arg) }
		    Atualiza o PC para o valor que foi solicitado pelo
		    por algum dos tipos de Jump, esse valor pode ser
		    tanto uma label quanto um número que representa
		    a linha do programa criado pelo usuário.
		    
		    {\textcolor{NavyBlue}{ static void RET(RVM rvm) }
		    Essa função trabalha em conjunto com o CALL,
		    já que ela recupera o valor que o PC tinha antes de
		    ser alterado pelo próprio CALL.
		
		\subsubsection{ IO.java }
		    Essa classe controla as funções que interpretam
		    os comandos IO (Input/Output) que o usuário 
		    passar na pilha de comandos, que no caso, só
		    temos o print (
		    {\textcolor{NavyBlue}{ static void PRN(RVM rvm) }
		    ). 
		    
		    Nessa função, desempilhamos o topo da pilha e
		    imprimimos seu valor.
		
		\subsubsection{ Jumps.java }
		    Assim como as classes Arit e IO, essa classe
		    também executa os comandos passados pelo usuário,
		    só que, desta vez, com funções Jump. Como o 
		    {\textcolor{NavyBlue}{JIT}  (Jump If True), 
		    {\textcolor{NavyBlue}{JIF}  (Jump If False), 
		    {\textcolor{NavyBlue}{JMP}  (JuMP) e
		    {\textcolor{NavyBlue}{JCMP} (Jump CoMPare),
		    atuando de tal forma que
		    o PC é atualizado para o endereço passado.
		    
		\subsubsection{ Mem.java }
		    Da mesma forma que algumas classes anteriores, essa
		    função cuida dos comandos passados pelo usuário.
		    Sendo esses comandos, formas de controlar o
		    armazenamento e recuperação de dados na memória.
		    
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ static void STO(RVM rvm, 
		    Stackable position) }
		    que armazena o que está no topo da pilha de dados,
		    na memória de acordo com o parâmetro recebido, que
		    representa o endereço de memória em que se deseja
		    ser salvo o dado. E após esse processo, retira o
		    dado da pilha de dados.
		    
		    {\textcolor{NavyBlue}{ static void RCL(RVM rvm, 
		    Stackable position) }
		    que recupera o que foi armazenado em um determinado
		    endereço de memória, que é passado pelo usuário como
		    parâmetro, e joga esse dado na pilha de dados.
		    
		\subsubsection{ Net.java }
		    Essa classe é responsável pela comunicação entre os
		    robôs, nela montamos uma rede onde a  informação é 
		    passada da memória para a pilha de cada robô ao receber
		    a mensagem e passada da pilha do robô para a memória
		    ao mandar uma mensagem.
		    
		\subsubsection{ Prog.java }
		    Controla as funções que não tem uma função específica
		    no programa, como o END (que não faz mais nada além de
		    finalizar o programa) e NOPE (que não realiza nada).
		    
		    Em: {\textcolor{NavyBlue}{ static void END(RVM rvm) }}
		    atualizamos o PC para -1 (local onde não há nenhum
		    outro comando) o que faz com que o programa seja
		    finalizado.
		    
		\subsubsection{ Returns.java }    
		    É uma interface que cuida dos retornos do sistema, onde
		    ele atribui 1 ou 0 para cada tipo de retorno.
		    
		\subsubsection{ RVM.java }
			A \emph{Robot Virtual Machine} (\textbf{RVM}) é a classe 
        	principal que controla o 'cérebro' dos robôs, servindo como o
		    interpretador para os comandos interpretados. Cada 
		    instância da classe RVM possui os seguintes atributos:
		    
		    \begin{itemize}
		        
		        \item PROG:  Vetor com os comandos do programa, conforme
		                     o formato criado pelo montador;
		        \item DATA:  Vetor com a pilha principal de memória, no 
		                     qual serão armazenados os dados colocados 
		                     com comandos de manipulação da pilha;
		        \item PC:    Registrador para a posição atual de execução 
		                     dos comandos dentro do vetor PROG;
		        \item RAM:   Memória auxiliar, a ser utilizada para funções;
		        
		        \item CTRL:  Vetor de controle dos retornos das funções 
		                     (callbacks);
		        \item LABEL: Hash com as posições associadas a cada LABEL
		                     criado como marcador no código da RVM.
		    \end{itemize}
				
        \subsubsection{ State.java }
		    É uma estrutura chamada Enum, onde dizemos que os
		    estados podem ser somente as mostradas a seguir:
		    {\textcolor{NavyBlue}{SLEEP} e
		    {\textcolor{NavyBlue}{ACTIVE}.
		    
		    Assim, quando o robô não tiver mais energia, por
		    exemplo, seu estado será SLEEP e o robô não terá
		    mais movimentos.				
				
		\subsubsection{ Stk.java }
		    Cuida das funções que mexem diretamente com a
		    memória, como 
		    {\textcolor{NavyBlue}{PUSH}, 
		    {\textcolor{NavyBlue}{POP} e 
		    {\textcolor{NavyBlue}{DUP}.
		    Que implementam um dado no topo da pilha, o retiram
		    e duplicam o q está no topo, respectivamente.
		    
		\subsubsection{ Syst.java }
		    Essa é a classe que controla os comandos destinados
		    aos próprios robôs, como por exemplo
		    {\textcolor{NavyBlue}{HIT},
		    {\textcolor{NavyBlue}{DRAG},
		    {\textcolor{NavyBlue}{DROP},
		    {\textcolor{NavyBlue}{MOVE},
		    {\textcolor{NavyBlue}{SEE} e
		    {\textcolor{NavyBlue}{LOOK}.
		    
		    Sendo que 
		    {\textcolor{NavyBlue}{private static void action(RVM rvm,
		    String type)} guarda o tipo de comando passado da
		    pilha de dados, cria uma {\textcolor{NavyBlue}{Operação} 
		    op e verifica se essa operação é válida, caso seja, 
		    coloca na pilha de dados as informações necessárias 
		    que serão lançadas como resposta.
		    
		\subsubsection{ Tests.java }
		    Controla as funções que executam os comandos do
		    usuário e que são do tipo comparativas.
		    Entre elas, estão 
		    {\textcolor{NavyBlue}{CMP}, 
		    {\textcolor{NavyBlue}{EQ}, 
		    {\textcolor{NavyBlue}{NE}, 
		    {\textcolor{NavyBlue}{LE}, 
		    {\textcolor{NavyBlue}{LT},
		    {\textcolor{NavyBlue}{GE}, 
		    {\textcolor{NavyBlue}{GT}
		    que dão pop no topo da pilha de dados, duas vezes,
		    e compara os dois dados de acordo com a função
		    especificada. 
		    
		    Depois desse processo, é empilhado um dado do tipo
		    Num (que é um Stackable) na pilha de dados.
		    De tal forma que, caso a comparação seja verdadeira,
		    é empilhado um Num de conteúdo 1, caso contrário,
		    um Num de conteúdo 0. 
		
		\subsubsection{ Var.java }
		    Essa classe cuida dos comandos voltados a criação de
		    variáveis no programa do usuário. Tais como alocação
		    de memóiria, liberação de memória, receber e alterar
		    o valor da variável.
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{static void ALOC(RVM rvm, 
		    Stackable name)}
		    que recebe o nome da variável como parâmtro e 
		    verifica na RVM se não existe outra com outro nome.
		    Caso negativo, é criada uma variável com valor null.
		    
		    {\textcolor{NavyBlue}{static void FREE(RVM rvm, 
		    Stackable name)}
		    que remove a variável com o nome name da RVM.
		    
		    {\textcolor{NavyBlue}{static void SET(RVM rvm, 
		    Stackable name)}
		    que pega o valor do topo da pilha e armazena na
		    variável com o nome name, caso ela exista.
		    
		    {\textcolor{NavyBlue}{static void GET(RVM rvm, 
		    Stackable name)}
		    que pega o valor da variável e o coloca no topo da
		    pilha de dados.
		
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Scenario}
	    Nesse package, temos as classes que representam
	    os vários tipos de elementos contidos nocenários do 
	    jogo.
	    Para o controle desses elementos, usamos a interface
	    Scenario que além de padronizar o tipo de dado,
	    força todas as classes a terem uma função que
	    cuida dos danos adquiridos ao decorrer do jogo
	    (por exemplo, quando uma pedra é atacada por um robô,
	    ela perde vidas, e perdendo um determinado número de
	    vidas, ela é destruida).
	    
	    Dentre eles há rochas, árvores e água.
		
		\subsubsection{ Rock.java }
		    A pedra retira o dano recebido do seu HP(vida) e
		    o devolve quando é chamada a função que retorna o
		    HP.
		    E ao imprimirmos uma pedra, teremos como resultado
		    "(O) Rock".
		
		\subsubsection{ Scenario.java }
		    Interface que padroniza os diferentes tipos de
		    elementos do cenários em um tipo Scenario, além 
		    de padronizar a função que cuida dos danos 
		    recebidos por cada objeto.
		    
		    Tem-se as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ public int getHP() }
		    Retorna o número de vidas do presentes no robô.
		    
            {\textcolor{NavyBlue}{ public int takeDamage (int damage) }
            Essa é a função que cuida dos danos recebidos 
            pelo objeto, recebendo o dano como parâmetro
            para poder subtrair vidas do cenário.
		    
		\subsubsection{ Tree.java }
		    Assim como a pedra, a árvore recebe danos e os subtrai
		    de seu HP.
		    E quando a imprimimos através das funções IO, temos
		    "( ) Tree".
		    %"(♣) Tree". 
		
		\subsubsection{ Water.java }
		    A água, assim como a base, não recebe dano.
		    Portanto ela tem um número específico de HP
		    que se manterá intancto aos ataques sofridos.
		    Ao imprimirmos uma árvore, temos "( ) Water".
		    %"(≈) Water".

\bigskip
\bigskip
\bigskip
\bigskip 	

	\subsection{Stackable}
		Nesse package, temos a interface Stackable que
		será o tipo responsável pela atribuição da
		característica empilhável dos empilháveis.
		
		\subsubsection { Addr.java }
			Os objetos do tipo Addr são endereços de
			determinados valores em um vetor. Portanto
			são representados por inteiros.
			
			Nele encontramos as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Addr(int address) }
			que é o construtor de objetos do tipo Addr.
			
			{\textcolor{NavyBlue}{ public int getAddress() }
			que retorna o valor do endereço como um 
			inteiro.
		
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%			
		
		\subsubsection { Around.java }
			Tem como característica uma matriz de Strings
			que representam as direções as quais os robôs
			devem seguir para chegar aos determinados
			pontos visinhos.
			
			Nela, encontramos as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Around(Terrain[] seeing) }
   
    
    		{\textcolor{NavyBlue}{ public String[] indexToPosition
    		(int index) }
   			é responsável pelo retorno da String de coordenadas 
   			que o robô deve seguir para chegar a sua visinhança.
   			Ela recebe como parâmetro, o número de casas de 
   			distância que o robô pode atacar/ver.
		    
		    {\textcolor{NavyBlue}{ public void print() }
    		função para modo debuger!
    
		    {\textcolor{NavyBlue}{ public String toString() }
		    devolve a String "around", incluindo para saídas de IO.

		
		\subsubsection { Attack.java }
			Os objetos do tipo Attack são os tipos de
			ataque que o robô pode realizar. Por enquanto,
			temos o ataque MEELE que é a curta distancia(
			somente poderá atacar o que estiver nas casas
			visinhas a sua) ou RANGED que é a uma distância
			determinada pelas características do robô (caso
			o robo tenha um poder de atacar a 3 de distância,
			ele irá atingir o que está a até 3 casas de
			distância da sua).
			
			Nela, temos as seguintes funções:
					
			{\textcolor{NavyBlue}{ public Attack(String s) }
   			um construtor que monta o objeto a partir da
   			String passada.
			
			{\textcolor{NavyBlue}{ public String getAttack() }
			retorna o tipo de ataque em forma de String.
		
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.	
		
		\subsubsection { Coordinate.java }
		    Como empilhável, também temos o tipo Coordinate,
		    onde é possível representar as coorenadas de cada
		    hexágono em relação a Arena.
		    
		    Para ser criado, ele precisa de duas dimensões, I
		    e J (que podem ser passadas como int ou como Num
		    --- polimorfismo ---) de acordo com a representação
		    quadrada da matriz hexagonal.
		    
		    Essa classe tem métodos getters que devolvem as
		    coordenadas ou os pontos I e J e possui o toString
		    que devolve no formato [I,J];
		
		\subsubsection { Direction.java }
			Os objetos do tipo Direction são do tipo que
			orientará os robôs na arena em relação a 
			movimentação e ataque. Pelo fato de a arena
			ser formada por bases hexagonais, temos as
			direções 
			{\textcolor{NavyBlue}{E}  (leste), 
			{\textcolor{NavyBlue}{NE} (nordeste), 
			{\textcolor{NavyBlue}{NW} (noroeste),
			{\textcolor{NavyBlue}{W}  (oeste), 
			{\textcolor{NavyBlue}{SW} (sudoeste) e 
			{\textcolor{NavyBlue}{SE} (sudeste).
			Sempre que um objeto do tipo Direction for
			chamado pelo usuário, este deve ser retratado
			com o símbolo 
			{\textcolor{NavyBlue}{''->''}
			antes do seu conteúdo.
			
			Por exemplo, 
			{\textcolor{NavyBlue}{''->WE''}.
			
			A classe Direction possui armazenará o movimento
			como uma matriz de coordenadas, que terá
			determinados tipos de movimento quando o robô 
			estiver em uma linha par e outro tipo de movimento
			quando o mesmo estiver numa linha ímpar.
			Essas coordenadas são dadas de modo que, quando
			a somamos com as coordenadas do robô, ele se 
			movimentará para o local desehjado.
			Obs.: Quando a linha é par, usamos a 1ª linha da
			matriz, caso contrário, usamos a 2ª.
			
			Temos as funções:
			
			public Direction(String dir)
			que é o contrutor
			
			{\textcolor{NavyBlue}{ public Direction(int move, 
			int dir) } 
			que recebe a direção e a partir dela, preenche a matriz 
			com as respectivas direções.
			
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			static void ALOC(RVM rvm, Stackable name)
			{\textcolor{NavyBlue}{ public int[] get(int row) }
			Devolve um vetor com a direção a ser seguida, se
			a linha em que ele está for par, devolvemos a
			"( ) Tree".
			%"(♣) Tree".
			1ª linha da matriz, caso contrário, a 2ª.
			
			{\textcolor{NavyBlue}{  private void set(int even\_x, 
			int even\_y, int odd\_x, int odd\_y) }
			preenche a matriz com as direções que são recebidas
			como parâmetro.
		
		\subsubsection { Item }
			Item não é uma classe, é uma pasta com as 
			classes que representam objetos do tipo item
			(implementam a interface de itens),
			o tipo item é um empilhável que pode ser pego
			e destruído pelo robô.
			Dentre elas, temos a
			 
			{\textcolor{NavyBlue}{Crystal.java}
			 que é repsonsável pela criação de
			objetos cristais.
			
			a {\textcolor{NavyBlue}{Item.java}
			que é uma interface responsável pela atribuição 
			do tipo item às classes.
			
			e a {\textcolor{NavyBlue}{Stone.java} que é 
			responsável pela criação das pedras que são 
			destruíveis e colecionáveis pelos robôs.
			
		\subsubsection { Nil.java }
		    É um empilhável que representa as informações da 
		    memória utilizada na comunicação entre os robôs
		    (CACHE). 
		    É um stackable simples que possui apenas função
		    get(devolve o próprio objeto Nil) e toString;
			 
		\subsubsection { Num.java }
			É um empilhável do tipo número.
			Ela possui as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Num(double num) }
			que é o construtor, que cria o objeto usando
			um parametro numérico que é recebido.
    
    		{\textcolor{NavyBlue}{ public double getNumber() }
 	  		que retorna o valor de Num em formato double.
  
    		{\textcolor{NavyBlue}{ public String toString()}
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			
	    \subsubsection { Stack.java }
	        Essa classe controla as pilhas.
	        Desta forma, deve armazenar um vetor que contém
	        os valores que deverão ser armazenados na pilha,
	        além do controle com seu topo e seu tamanho
	        (esse controle é feito por variáveis do objeto).
	        
	        Nessa classe, temos a função que retorna o topo,
	        a que verifica se a pilha está vazia, a que dá push
	        (coloca no topo da pilha) e pop (tira o topo da 
	        pilha) e temos também a função que duplica o vetor
	        da pilha, pois, em JAVA, um vetor pode ser criado
	        somente se colocamos seu tamanho como um parâmetro
	        fixo, e como não sabemos o seu tamanho inicialmente,
	        duplicamos a pilha caso metade dela já esteja 
	        preenchida (isso é verificado na função ).
	         
			
		\subsubsection { Stackable.java }
			É a interface Stackable que se responsabiliza
			pelos objetos empilháveis. Essa interface não
			possui características exclusivas como funções
			e variáveis que seriam herdadas pelas classes
			desse tipo, é apenas para generalizar o tipo
			dos empilháveis.
			
		\subsubsection { Text.java }
			É criado o tipo de Stackable Text, onde 
			poderemos empilhar um texto ou String.
			Possui as seguintes funções:
			
			{\textcolor{NavyBlue}{public String getText() }
			que retorna o texto em si em formato String.
			
    		{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			
	    \subsubsection { Variable.java }
	        Essa classe representa as variáveis de modo que elas
	        sejam empilháveis. Desse modo, quando um usuário criar
	        uma variável em seu programa, esta poderá ser passada
	        para a pilha com comandos push e pop (internamente).
	        
	        Ela possui um contrutor que armazena somente o seu
	        nome em tipo String, um settter e um toString;
			
\bigskip
\bigskip
\bigskip
\bigskip
		
	\subsection{UI}
		A classe para modo texto da GUI percorre a matriz hexagonal 
		observando as características presentes em cada um dos terrenos 
		(tipo, itens e cenários). Então, realiza a impressão desses 
		elementos com auxílio de bibliotecas JAVA, simulando visualmente 
		o jogo em interface gráfica.
        
        \subsubsection{ graphical/Cell.java }
            É responsável pela criação dos terrenos em si.
            Desenha as células em forma hexagonal de acordo com as
            coordenadas x e y e o raio do hexágono que são recebidos
            por parâmetros no construtor.
        
        \subsubsection{ graphical/EditorFrame.java }
            Essa classe é responsável pela criação de um frame
            que contenha um JTextPanel.
            Que será uma nova janela onde o usuário poderá digitar o
            código que manipulará determinado robô de seu exército.
            Será um receptor do código em alto nível na fase seguinte.
            
        \subsubsection{ graphical/Graphical.java }
                A Graphical irá controlar toda a parte gráfica.
                Como agora possuímos dois tipos de frames sendo exibidos,
                precisamos de algo mais externo para controlar tudo.
                Portanto a Graphical irá manipular o que ocorre nos dois
                Frames, no que imprime o mapa e no que permite que o
                código dos robôs seja alterado.
                
                Nessa classe, usamos as bibliotecas Swing e AWT para
                utilizar os recursos gráficos destas.S
                
        \subsubsection{ graphical/Images.java }
            Cuida das imagens do jogo.
            Faz isso de tal forma que, apenas utilizando um nome
            atribuido a imagem, podemos acessá-la em seu  respectivo    
            diretório.
            E também possui uma função que transforma essa imagem
            como uma variável do tipo BufferedImage para que esta
            possa ser manipulada pelas funções das bibliotecas do
            JAVA.
            
            Possui getters para largura e comprimento da imagem.
            
        \subsubsection{ graphical/MapFrame.java }
            Representa o frame em que será exibido o mapa do
            jogo. Além de ser um meio de comunicação entre a Graphical
            e o Panel e o UserInterface.
            
            Ele também cria a área de texto onde são exibidas as 
            mensagens do jogo, como erro de código do programa do 
            usuário ou carregamento de determina imagem.
        
        \subsubsection{ graphical/Menu.java }
            Representa o frame em que será exibido o menu inicial.
            Nessa classe estão contidas apenas as características da
            janela.
            É chamado pelo main, que trabalha recursivamente enquanto
            o usuário não quiser se sair do jogo, e manda informações 
            para MenuPanel.
       
        \subsubsection{ graphical/MenuPanel.java }
            Representa o painel que está contido no frame Menu
            e controla a imagem exibida e os eventos de botões,
            devolvendo a resposta dos cliques para o Menu.
        
        \subsubsection{ graphical/MiniMapFrame.java }
            Representa o frame em que será exibido o mini mapa,
            usando as informações da classe mapa para imprimi-lo
            em tela.
       
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        \subsubsection{ graphical/Panel.java }
            É responsável pela imagem que será impressa no painel,
            portanto controla, desde árvores e cristais, a configurações
            dos hexágonos no mapa. Portanto possui uma matriz de cúlulas
            e o mapa como parâmetros.
            
            Percorre a matriz de terrenos do mapa e imprime cada célula 
            de acordo com a sua configuração.
            Se possuir robôs, pedras, árvores ou bases, estes também 
            serão impressos no painel.
            
            Este também tem acesso aos robôs que estão contidos no mapa,
            o que permite ver o quanto de vida ainda resta. 
            Dessa forma é possível mostrar na tela uma barrinha de vida 
            para cada robô.
            
            Também é responsável, por settar as fases do jogo, informando
            o mesmo de quando podemos continuar o jogo normalmente ou
            jogo, ou informar sobre perdedores e ganhadores.
            
            
            Nesse mesmo arquivo temos uma outra classe, a JRobot, que é
            responsável pela mudança de programa em tempo real de um
            robô. Nela, é permitido clicar em um robô e reescrever o 
            programa que o rege. 
            
            Isso é feito com eventos de mouse nas imagens Graphical2D.
            
        \subsubsection{ graphical/Phase.java }
            É uma estrutura Enum que define o Status atual do jogo,
            se ele está rodando normalmente, se o jogador foi vendeu
            ou perdeu.
            
            {\textcolor{NavyBlue}{ACTIVE},
		    
		    {\textcolor{NavyBlue}{LOOSER} e
            
            {\textcolor{NavyBlue}{WINNER}.
            
        \subsubsection{ graphical/UserInterface.java }
            Representa o painel de menu do jogo que está no mesmo
            frame que o mapa.
            É uma Thread que rodará paralelamente ao jogo em si, pois
            precisa estar constantemente atenta aos eventos dos botões.
            
            Nela temos o botão que oculta o aparecimento do mini mapa,
            o que cria novos robôs (perguntando seu nome) permitindo que
            esses sejam criados com arquivos já existentes ou com
            programas escritos pelo usuário.
            Há também o botão que controla a visibilidade da janela do
            editor de texto (onde o usuário irá digitar os seus 
            programas), outro botão que limpa o editor de texto e por
            fim, o que finaliza o jogo.
            
        \subsubsection{ textual/* }
            Esse jogo também pode ser exibido em modo texto (caractéres),
            (como foi feito na versão passado) para que possa ser exibido
            no terminal.
            Essa pasta contém classes que printam o jogo no terminal.
        
        \subsubsection{ Interfaces.java }
		    É uma estrutura chamada Enum, onde dizemos que as
		    interfaces podem ser somente as mostradas a seguir:
		    
		    {\textcolor{NavyBlue}{TEXTUAL} e
		    
		    {\textcolor{NavyBlue}{GRAPHICAL}.
        
        \subsubsection{ MENU.java }
            É uma estrutura Enum que representa o que a tela de menu
            deverá fazer, se ela irá iniciar um novo jogo ou se ela
            deverá fechar as telas, termiando a sessão de jogo.
            
            {\textcolor{NavyBlue}{EXIT} e
            
            {\textcolor{NavyBlue}{NEW\_GAME}.
		    
        \subsubsection{ Printable.java }
            É uma interface que reprenta tudo que pode ser graficamente
            impresso.
            Todas os objetos desse tipo devem ter uma função que retorna
            seu nome (String).
        
        \subsubsection{ UI.java }
            É uma interface que padroniza as funções que todos
            os modos de exibição (interfaces) devem ter.
            De acordo com ela, tanto a inteface gráfica quanto a textual
            devem ter as funções que pintam, pintam mapa, pintam o mini
            mapa, imprimem texto e avisam quem é o ganhador e o 
            perdedor.

\end{document}
