\documentclass[a4paper]{article}

% Linguagem
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}

% Pacotes matemáticos
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

% Fontes e identaçãp
\usepackage{setspace}                   % espaçamento flexível
\usepackage{indentfirst}                % indentação do primeiro parágrafo
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

% Pacotes para cores e modelos
\usepackage[a4paper,top=3.0cm,bottom=2.0cm,left=3.0cm,right=2.0cm]{geometry} \usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,
            colorlinks=true,citecolor=DarkGreen,linkcolor=DarkRed,
            urlcolor=DarkRed,filecolor=DarkGreen,
            bookmarksopen=true]{hyperref}

% Pacotes para itens
\usepackage{calc}  
\usepackage{enumitem}  

\title  {Projeto de Laboratório de Programação II - Fase 2}
\author {Karina Suemi, Vinícius Silva, Renato Cordeiro}
\date   {}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Introdução} \label{sec:introdução}

    Nesta fase, o projeto consiste na criação de uma máquina
    virtual em JAVA, juntamente com a implementação de funções
    que darão ao usuário o poder de controlar o robô através 
    de comandos usados com pilha de dados.
    Há também a criação da Arena, esta é resposável por controlar
    os robôs de forma que eles sejam impossibilitados de fazer
    movimentos não propícios. 
    
    E por último, temos os tipos de terrenos e objetos que estarão
    dispostos nele, como cristais, rochas ( como objetos ), bases, 
    água, árvores, entre outros ( como cenário ). 
    
    
    \subsection{Projeto}
    
    Os arquivos estão separados de acordo comcolor a seguinte estrutura de
    diretórios:
    \begin{itemize}
        \item \textbf{bin:}  Arquivo executável principal do programa;
        \item \textbf{doc:}  Pasta para a documentação, com este arquivo 
                             e a versão fonte em \LaTeX;
        \item \textbf{lib:}  Arquivos com classes/pacotes de Perl 
                             no formato \texttt{.pm};
        \item \textbf{test:} Arquivos de teste com código em Assembly
                             do montador/máquina virtual \texttt{.txt}.
    \end{itemize}
    
    \subsection{Estrutura}
      
        Para informações sobre o uso de programa e os seus 
        desenvolvedores, consultar os arquivos \href{run:../README.md}
        {\texttt{README.md}} e \href{run:../LICENSE}{\texttt{LICENSE}}.
        
        O programa consiste de três partes principais:
        \begin{itemize}
            \item \hyperref[sec:montador]        {Montador};
            \item \hyperref[sec:maquina_virtual] {Máquina Virtual};
            \item                                 Emulador.
        \end{itemize}
    
    \subsection{Emulador}
    
        O emulador é a parte mais simples do programa, e consiste de 
        um arquivo do tipo \texttt{.pl} nomeado 
        \href{run:../bin/robots.pl}{\texttt{robots.pl}} na pasta
        \texttt{bin/}. Para executá-lo, basta rodar o programa 
        passando como parâmetro na linha de comando um arquivo (de 
        extensão qualquer) com o assembly válido. 
        
        Caso haja erro de compilação, o programa será encerrado antes 
        da execução de qualquer comando. Caso o erro seja lógido 
        (\emph{runtime}), os erros serão impressos na saída de erros 
        (STDERR) no próprio prompt de comando.

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Montador} \label{sec:montador}

    O montador tem como função ler o programa em texto (que será 
    passado pelo usuário), ver se ele está formatado de maneira 
    correta e em caso positivo, é criada uma matriz 3 x n, sendo $n$ 
    o número de comandos, que será passada para a Máquina Virtual.
    
    O arquivo com o montador está no diretório de bibliotecas 
    \texttt{lib/} e é chamado \href{run:../lib/Cortex.pm}
    {\texttt{Cortex.pm}}
    
    \bigskip\bigskip
    
    No caso, as linhas do programa de entrada terão que seguir o 
    seguinte padrão:

    \begin{center}
        \textbf{[ Comando, Argumento, Label ]}
    \end{center}
    
    O montador devolverá erro em caso de comandos que não sejam 
    compatíveis com seus respectivos tipos de argumentos. No caso da
    entrada ser: 
    
    \begin{description}
    %[leftmargin=!,labelwidth=\widthof{\bfseries The longest label}]

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        \item [\textbf{\textcolor{red}{x}} "ADD Olá"] 
        O comando ADD não deveria receber argumentos, e como não é o 
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "ADD"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "PUSH Oie!"] 
        O comando PUSH deveria receber argumentos numéricos, e como não é 
        o caso, o programa passará \emph{undef} para a Máquina Virtual.
    
        \item [\textcolor{green}{\checkmark} "PUSH 100"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "JIF 5uvas"] 
        O comando JIF deveria receber argumentos em forma de texto (pode
        conter números, desde que não sejam 1º caracter), e como não é o
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "JIF uvas5"] 
        Este seria o correto.

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \end{description}

    \bigskip\bigskip

    Segue a tabela com os argumentos necessários para cada tipo de 
    comando:
    
    \begin{center}
      \begin{tabular}{|c|l|rc|}
                     &  ADD - DIV - DUP - END - EQ - GE - GT   \\
          Vazio      &  MOD - LE - LT - MUL - NE - POP - PRN   \\
                     &  SUB - RET - MOVE - DRAG - DROP - HIT   \\
                     &  LOOK - ITEM - SEE - SEEK               \\
                     &										   \\
          Numérico   &  RCL - STO                              \\
          			 &										   \\
          String     &  JMP - JIF - JIT - CALL                 \\
          			 &										   \\
          Empilhável &  crystal - stone                        \\
      \end{tabular}
    \end{center}  
    
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
\section{Máquina Virtual} \label{sec:maquina_virtual}
    
    A máquina virtual (RVM, \emph{Robot Virtual Machine}, consiste em 
    um conjunto de módulos localizados no diretório lib/RVM que integram 
    o pacote/classe RVM. 
    
    Os arquivos do módulo são:
    \begin{itemize}
        \item \href{run:../lib/RVM/RVM.pm}       {RVM.pm        }
        \item \href{run:../lib/RVM/Overload.pm}  {Overload.pm   }
        \item \href{run:../lib/RVM/ctrl.pm}      {ctrl.pm       }
        \item \href{run:../lib/RVM/functions.pm} {functions.pm  }
        \item \href{run:../lib/RVM/f\_arit.pm}   {f\_arit.pm    }
        \item \href{run:../lib/RVM/f\_io.pm}     {f\_io.pm      }
        \item \href{run:../lib/RVM/f\_jumps.pm}  {f\_jumps.pm   }
        \item \href{run:../lib/RVM/f\_memo.pm}   {f\_memo.pm    }
        \item \href{run:../lib/RVM/f\_stk.pm}    {f\_stk.pm     }
        \item \href{run:../lib/RVM/f\_tests.pm}  {f\_tests.pm   }
    \end{itemize}
    
    \subsection{RVM.pm}
        
        A \emph{Robot Virtual Machine} (\textbf{RVM}) é o pacote 
        principal que controla o 'cérebro' dos robôs, servindo como o
        interpretador para o formato criado pelo montador. Cada 
        instância da classe RVM possui os seguintes atributos:
        
        \begin{itemize}
            
            \item PROG:  Vetor com os comandos do programa, conforme
                         o formato criado pelo montador;
            \item DATA:  Vetor com a pilha principal de memória, no 
                         qual serão armazenados os dados colocados 
                         com comandos de manipulação da pilha;
            \item PC:    Registrador para a posição atual de execução 
                         dos comandos dentro do vetor PROG;
            \item RAM:   Memória auxiliar, a ser utilizada para funções;
            \item CTRL:  Vetor de controle dos retornos das funções 
                         (callbacks);
            \item LABEL: Hash com as posições associadas a cada LABEL
                         criado como marcador no código da RVM.
        \end{itemize}
        
        O módulo RVM contém dois métodos, responsáveis por agirem como
        construtor (\textbf{new}) e inicializador de programa 
        (\textbf{upload}) para os objetos da RVM.
        
    \subsection{Overload.pm}
        
        Módulo auxiliar que faz parte da classe da RVM. Sua principal
        função é fornecer a sobrecarga do operador \emph{double quote}
        (\textbf{qq//} ou \textbf{"}), de modo a possibilitar a 
        impressão dos valores armazenados dentro da RVM.
    
    \subsection{ctrl.pm}
    
        O módulo auxiliar do controlador contém o método responsável 
        por realizar a execução do programa armazenado no atributo 
        \textbf{PROG} do objeto da classe RVM. 
        
        Começando da posição 0, a cada posição de PROG realiza a 
        chamada da função correspondente, usando os argumentos (se 
        disponíveis ou necessários). Nesse processo, atualiza o PC 
        (registrador de posição) para realizar a atualização 
        necessária (avançar para o próximo comando ou fazer um desvio).
        
        Quando a função retorna um erro, lança uma exceção (erro de 
        \emph{runtime}), que pode ser de 3 tipos:
        \begin{itemize}
            
            \item Falha de segmentação: tentativa de acessar região 
                                        não definida da memória -
                                        overflow/underflow da
                                        pilha de dados DATA;
                                        
            \item Operação inválida:    quando o operando não é do tipo 
                                        válido;
                                        
            \item Label desconhecido:   o LABEL acessado pelo comando 
                                        de controle de \emph{workflow} 
                                        não foi definido.
                                        
        \end{itemize}
        
    \subsection{functions.pm}
        
        Módulo auxiliar que reúne as funções criadas em outros módulos 
        da Máquina Virtual. Com ele é possível ter acesso às funções 
        que podem ser executadas pela RVM.        
        
        Para cada comando implementado nos módulos listados, as funções
        recebem como argumento o objeto do pacote sobre o qual a ação 
        deve ser realizada, o argumento (se não existir, é \emph{undef},
        e é descartado) e o número de elementos da pilha.
        
        Todas as funções retornam a atualização do número de elementos
        da pilha, estritamente maior que 0, ou números negativos, 
        indicando as exceções listadas na seção anterior.

    \subsection{f\_arit.pm}
        
        O f\_arit.pm contém as funções aritméticas que o programa deve
        executar, como a soma, subtração, multiplicação e divisão.
        
        Ele desempilha o último e penúltimo valores a partir do topo 
        da pilha de dados. Caso não existam dois valores, a função 
        lança uma exceção.
        
        \textbf{Observação}: As 4 operações funcionam de maneira
        análoga.        
        
    \subsection{f\_io.pm}
        
        Este módulo é responsável pela execução da função PRN 
        (\emph{PRiNt}), que imprime na STDOUT o valor do topo da 
        pilha de dados.
            
    \subsection{f\_jumps.pm}
        
        O f\_jumps.pm contém as funções responsáveis pela execução dos
        comandos associados a jumps, como JMP (\emph{JuMP}), JIT 
        (\emph{Jump If True})e JIF (\emph{Jump If False}).
        
        No caso de \emph{JMP}, este irá atribuir o argumento passado 
        ao registrador de instrução (PC), realizando um salto 
        incondicional a esta posição. Caso não existam instruções
        na posição indicada, lança uma exceção do tipo \emph{Falha
        de Segmentação}.
        
        Para os outros comandos de salto condicional (\emph{JIT}/
        \emph{JIF}), também é possível passar como argumento um
        LABEL. Caso esta posição não exista, lança uma exceção
        específica.
    
    \subsection{f\_memo.pm}
        
        O f\_memo.pm  contém as funções que mexem com endereçamento
        de memória: \emph{STO} e \emph{RCL}.
        
        Este módulo é o responsável por realizar a transferência de
        dados entre o vetor de memória principal (DATA) e o vetor 
        auxiliar (RAM). Cada um deles recebe como argumento o endereço
        (posição do vetor), de modo que:
        \begin{itemize}
            
            \item STO: retira o valor de DATA e coloca na posição 
                       \$arg de RAM;
            \item RCL: realiza o processo inverso.
            
        \end{itemize}
        
        Ambas as funções devolvem uma exceção do tipo \emph{Falha de
        Segmentação} caso não haja elementos em DATA (\emph{STO}) ou 
        na posição de RAM (\emph{RCL}).
        
    \subsection{f\_stk.pm}
        
        O submódulo f\_stk.pm contém as funções de manipulação de pilha.
        \emph{PUSH}, \emph{POP} e \emph{DUP}.
        \begin{itemize}
            
            \item PUSH: Recebe um argumento e o coloca no topo da pilha 
                        de dados DATA;
            
            \item POP:  Retira o dado que estiver no topo da pilha de 
                        dados; 
            
            \item DUP:  Empilha uma cópia do topo da pilha.
        
        \end{itemize}
        
    \subsection{f\_tests.pm}
            
        O submódulo f\_tests.pm armazena as funções lógicas. Cada uma
        dekas retira os dois elementos do topo da pilha e, em seguida,
        realiza uma comparação, usando como primeiro argumento o topo
        da pilha.
        
        Considerando 'A' o topo da pilha e 'B' o elemento anterior,
        os comandos realizam as seguintes ações, em seus análogos 
        para números:
        \begin{itemize}
            \item EQ: A == B
            \item GT: A >  B
            \item GE: A >= B
            \item LT: A <  B
            \item LE: A <= B
            \item NE: A != B
        \end{itemize}
    









\newpage
\newpage

\section{Packages}
	Foram criados pacotes para facilitar a divisão
	e entendimento do código.
	
	\subsection{Arena}
		O package "Arena" cuida das classes que envolvem os
		terrenos e a arena em si, bem como o classe que cuida
		da autorização de execução de determinadas funções que
		necessitam da consultoria da arena para serem executadas.
		
		\subsubsection{ Action.java }
		%%%%%%%%*********&&&&&&&&&&&&&&&&&------------xxxxxxxxxxxxxx
		    Aqui é onde encontramos a implementação das funções
		    utilizadas diretamente pelos robôs, tais como 
		    {\textcolor{NavyBlue}{HIT},
		    {\textcolor{NavyBlue}{}
		    
		\subsubsection{ Appearence.java }
		    É uma estrutura chamada Enum, onde dizemos que as
		    aparências podem ser somente as mostradas a seguir:
		    {\textcolor{NavyBlue}{DIRT},
            {\textcolor{NavyBlue}{GRASS},
            {\textcolor{NavyBlue}{ROCKY},
            {\textcolor{NavyBlue}{ICE},
            {\textcolor{NavyBlue}{WATER},
            {\textcolor{NavyBlue}{SAND},
            {\textcolor{NavyBlue}{JUNGLE} e
            {\textcolor{NavyBlue}{TUNDRA}.
		
		\subsubsection{ Map.java }
		    A classe mapa vai cuidar da matriz de terrenos, e 
		    podemos assumir que cada mapa terá um clima diferente.
		    
		    É nessa classe que também criamos os times a partir
		    do parâmetro número do time passado, onde temos uma 
		    matriz representando jogadores de determinado time.
		    
		    Também inserimos exércitos e removemos Scenários.
		    Como nas seguintes funções:
		    
		    {\textcolor{NavyBlue}{public Scenario
		    removeScenario(int i, int j)}
		    que eliminará os Scenários do terreno com as coordenadas
		    passadas como parâmetro. Essa função serve para o caso 
		    de termos ataque a árvores e até mesmo a morte de robôs,
		    já que estes também são do tipo Scenario.
		    
		    {\textcolor{NavyBlue}{public Robot insertArmy(String
		    name, int player, int ID, int i, int j, String pathToProg)}
            que irá inserir um robô de acordo com os parâmetros
            recebidos, como nome do robô, a qual jogador ele pertence,
            o seu ID e as suas coordenadas.
            Essa função irá criar esse robô e implementá-lo no como 
            um Scenario nas coordenadas indicadas da arena.
		    
		\subsubsection{ Robot.java }
		%%%%%%%%*********&&&&&&&&&&&&&&&&&------------xxxxxxxxxxxxxx
		
		\subsubsection{ Terrain.java }
		    Cada terrain é um empilhável e possui um tipo de 
		    rugosidade, uma aparência e possivelmente um
		    Scenario.
		    
		    A maioria de suas funções, além do construtor ( que
		    irá receber a aparência e a partir dela, determinar 
		    o tipo de rugosidade ), tem-se basicamente getters,
		    setters e removedores de características da classe.
		    É válido lembrar que utilizamos polimorfismo para o
		    cnstrutor dessa classe, pois há vários tipos dessa
		    função que recebem diferentes tipos e números de
		    argumentos.
		    
		
		\subsubsection{ Type.java }
		    Assim como em Appearence, type também é um Enum, só
		    que dessa vez, representa os tipos de terreno da
		    arena. Sendo eles, por enquanto:
		    {\textcolor{NavyBlue}{NORMAL} e 
            {\textcolor{NavyBlue}{ROUGH}.
		
		\subsubsection{ Weather.java }						
		    Assim como Appearence e Type, Weather é do tipo Enum,
		    representando desta vez. os vários tipos de clima da
		    arena. Sendo eles:
		    
		    {\textcolor{NavyBlue}{CONTINENTAL},
            {\textcolor{NavyBlue}{ARTICAL},
            {\textcolor{NavyBlue}{DESERTIC} e
            {\textcolor{NavyBlue}{TROPICAL}.
		
		\subsubsection{ World.java }				
		%%%%%%%%*********&&&&&&&&&&&&&&&&&------------xxxxxxxxxxxxxx	
		
		
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
		
				
	\subsection{Exception}
		O package "Exception" cuida dos lançamentos de exceção
		que o programa gera para erros no código que será recebido
		do usuário.

		Como por exemplo as exceções de falha de segmentação,
		operações inválidas, erros de tipo, variáveis não
		inicializadas, entre outros.
		
		As classes desse package são chamadas pelas outras classes
		que utilizam essa forma de mandar exceção.
		 
	\subsection{Operation}
		\subsubsection{ Operation.java }
		%%%%%%%%*********&&&&&&&&&&&&&&&&&------------xxxxxxxxxxxxxx
		
	\subsection{Parameters}
		\subsubsection{ Debugger.java }
		%%%%%%%%*********&&&&&&&&&&&&&&&&&------------xxxxxxxxxxxxxx
		
		\subsubsection{ Game.java     }
		%%%%%%%%*********&&&&&&&&&&&&&&&&&------------xxxxxxxxxxxxxx
		
	\subsection{Parser}
		\subsubsection{ Parser.java }
		    O parser recebe um vetor de trincas (comando, argumento,
		    label), analisa as variáveis conforme o tipo correspondente 
		    no java e monta uma classe com o mesmo nome do programa em 
		    assembly.
		    
		    Adicionalmente, o programa cria um arquivo "Parser.xml"
		    para ser rodado pelo Ant e compilar todos os códigos no
		    diretório do package.
				
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Random}
	    Aqui criamos os mapas de determinados cenários,
	    gerados de forma probabilística, de modo que
	    o mesmo cenário se altere de acordo com a semente
	    passada. Cada cenário usa os tipos Scenario que são
	    os elementos que compõe os cenários.
	    
		\subsubsection{ CalmField.java }
		    Gera um cenário com árvores, rochas, pedras e 
		    cristais no terreno de forma probabilística.
		    Não podemos esquecer que ela gera as bases
		    necessárias para cada time.
		    
		\subsubsection{ Desert.java }
		    Gera um cenário com rochas, pedras, cristais e
		    bases de uma forma aleatoriezada e tenha as
		    características de um deserto.
		    
		\subsubsection{ Jungle.java }
		    Gera um cenário com árvores, rochas, pedras,
		    cristais e bases. Também possui um rio gerado
		    e distribuido probabilisticamente em meio a 
		    arena. 
		    
		    Esse rio possui partes de água mais rasas
		    e outras mais profundas, são as chamadas
		    deep water e water respectivamente.
		
		\subsubsection{ RamdomMap.java }
    		É responsável pela geração do mapa. Recebe 
    		parâmetros indicando qual será o tipo de
    		clima e os associa com o respectivo tipo
    		de mapa.
    		
    		Em sua outra função, ela gera o mapa, colocando
    		os determinados símbolos nos seus terrenos.
    		
		\subsubsection{ Theme.java }
		    Essa é uma interface que padroniza todos os 
		    tipos de temas, como JUNGLE, DESERT e WINTER.
		    Esse tipo de dado possui uma função específica
		    que retorna uma matriz representando o mapa
		    criado. 
		
		\subsubsection{ Winter.java }
		    Gera um cenário com árvores, rochas, pedras, 
		    cristais e bases de forma aleatória. Além de
		    gerar um rio congelado (água) no centro da arena.
		    

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Robot}
	    Esse package cuida das funções atreladas aos robôs
	    si, entre elas está a RVM e as funções que interpretam
	    os comandos utilizados pelos usuários.
	    
		\subsubsection{ Arit.java }
		    Essa classe controla as funções que interpretam
		    os comandos aritméticos que o usuário passar na
		    pilha de comandos, como por exemplo: Soma,
		    subtração, divisão, Multiplicação e Resto.
		    Tudo isso é manipulado na pilha de dados,
		    recebemos os valores de lá, e mandamos a resposta
		    para o topo da mesma.
		    
		    Temos a seguinte função:
		    
		    {\textcolor{NavyBlue}{ private static final void 
		    calculate(RVM rvm, Operation op) }
		    que cuida da generalização do trabalho realizado 
		    na pilhaEssa classe controla as funções que interpretam
		    os comandos aritméticos que o usuário passar na
		    pilha de comandos, como por exemplo: 
		    {\textcolor{NavyBlue}{ADD} ( Soma ),
		    {\textcolor{NavyBlue}{SUB} ( Subtração),
		    {\textcolor{NavyBlue}{DIV} ( Divisão ), 
		    {\textcolor{NavyBlue}{MUL} ( Multiplicação ) e 
		    {\textcolor{NavyBlue}{MOD} ( Resto ).
		    Tudo isso é manipulado na pilha de dados,
		    recebemos os valores de lá, e mandamos a resposta
		    para o topo da mesma. de dados pelas funções aritméticas.
		        
		\subsubsection{ Check.java }
		    Essa função tem como objetivo checar o terreno em
		    si e sua visinhança, bem como 
		    
		    {\textcolor{NavyBlue}{  static void ITEM(RVM rvm) }
		    que dá um pop na pilha caso o topo seja um terreno
		    e empilha os itens contidos nesse terreno na pilha
		    de dados.
		    
		    {\textcolor{NavyBlue}{  static void SEEK(RVM rvm) }
		    que verifica se o topo é um Stackable e desempilha
		    , depois verifica se o topo é um Around, e desempilha.
		    Depois, percorre a visinhança do próprio robô 
		    (que dependerá do quão longe o robô enxerga)
		    e tenta encontrar Items nessa visinhança.
		    
		    Isso auxilia quando o robô for procurar cristais,
		    por exemplo, fazendo com que ele não precise estar
		    necessariamente na casa do cristal para notar a 
		    sua presença.
		    
		\subsubsection{ Command.java }
		    Cria objetos do tipo comando, para serem manipulados
		    da mesma forma na pilha de comandos.
		    Tem como parâmetros o próprio comando, os argumentos
		    do tipo Stackable e a label que caracterizam as linhas
		    passadas pelo usuário no programa que o mesmo cria em
		    baixo nível.
		    Na classe, também temos as funções básicas getters e
		    setters de determinadas características de cada
		    comando.
		    
		\subsubsection{ Ctrl.java }
		    É um comunicador que interpreta um comando do programa
		    do usuário em forma de String (por exemplo: "JMP") e 
		    chama a respectiva função, passando os seus parâmetros 
		    para ela.
		    
		    Dentre esses comandos que ela interpreta, estão também
		    aqueles que podem ser executados pelos robôs, como
		    {\textcolor{NavyBlue}{MOVE}, 
		    {\textcolor{NavyBlue}{HIT}, 
		    {\textcolor{NavyBlue}{DRAG}, 
		    {\textcolor{NavyBlue}{DROP}, 
		    {\textcolor{NavyBlue}{SEE} e 
		    {\textcolor{NavyBlue}{LOOK}.
		    
		\subsubsection{ Func.java }
		    É responsável pelas funções CALL e RET que controlam
		    o valor do PC quando comandos do tipo Jump são
		    executados.
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ static void CALL(RVM rvm, 
		    Stackable arg) }
		    Atualiza o PC para o valor que foi solicitado pelo
		    por algum dos tipos de Jump, esse valor pode ser
		    tanto uma label quanto um número que representa
		    a linha do programa criado pelo usuário.
		    
		    {\textcolor{NavyBlue}{ static void RET(RVM rvm) }
		    Essa função trabalha em conjunto com o CALL,
		    já que ela recupera o valor que o PC tinha antes de
		    ser alterado pelo próprio CALL.
		
		\subsubsection{ IO.java }
		    Essa classe controla as funções que interpretam
		    os comandos IO (Input/Output) que o usuário 
		    passar na pilha de comandos, que no caso, só
		    temos o print (
		    {\textcolor{NavyBlue}{ static void PRN(RVM rvm) }
		    ). 
		    
		    Nessa função, desempilhamos o topo da pilha e
		    imprimimos seu valor.
		
		\subsubsection{ Jumps.java }
		    Assim como as classes Arit e IO, essa classe
		    também executa os comandos passados pelo usuário,
		    só que, desta vez, com funções Jump. Como o 
		    {\textcolor{NavyBlue}{JIT}  (Jump If True), 
		    {\textcolor{NavyBlue}{JIF}  (Jump If False), 
		    {\textcolor{NavyBlue}{JMP}  (JuMP) e
		    {\textcolor{NavyBlue}{JCMP} (Jump CoMPare),
		    atuando de tal forma que
		    o PC é atualizado para o endereço passado.
		    
		\subsubsection{ Mem.java }
		    Da mesma forma que algumas classes anteriores, essa
		    função cuida dos comandos passados pelo usuário.
		    Sendo esses comandos, formas de controlar o
		    armazenamento e recuperação de dados na memória.
		    
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ static void STO(RVM rvm, 
		    Stackable position) }
		    que armazena o que está no topo da pilha de dados,
		    na memória de acordo com o parâmetro recebido, que
		    representa o endereço de memória em que se deseja
		    ser salvo o dado. E após esse processo, retira o
		    dado da pilha de dados.
		    
		    {\textcolor{NavyBlue}{ static void RCL(RVM rvm, 
		    Stackable position) }
		    que recupera o que foi armazenado em um determinado
		    endereço de memória, que é passado pelo usuário como
		    parâmetro, e joga esse dado na pilha de dados.
		    
		\subsubsection{ Prog.java }
		    Controla as funções que não tem uma função específica
		    no programa, como o END (que não faz mais nada além de
		    finalizar o programa) e NOPE (que não realiza nada).
		    
		    Em: {\textcolor{NavyBlue}{ static void END(RVM rvm) }}
		    atualizamos o PC para -1 (local onde não há nenhum
		    outro comando) o que faz com que o programa seja
		    finalizado.
		    
		\subsubsection{ RVM.java }
		%%%%%%%%*********&&&&&&&&&&&&&&&&&------------xxxxxxxxxxxxxx
		    Essa classe, mesmo que indiretamente, controla a
		    pilha de dados e de comados do usuário, o PC, 
		
		\subsubsection{ Stk.java }
		    Cuida das funções que mexem diretamente com a
		    memória, como 
		    {\textcolor{NavyBlue}{PUSH}, 
		    {\textcolor{NavyBlue}{POP} e 
		    {\textcolor{NavyBlue}{DUP}.
		    Que implementam um dado no topo da pilha, o retiram
		    e duplicam o q está no topo, respectivamente.
		    
		\subsubsection{ Syst.java }
		    Essa é a classe que controla os comandos destinados
		    aos próprios robôs, como por exemplo
		    {\textcolor{NavyBlue}{HIT},
		    {\textcolor{NavyBlue}{DRAG},
		    {\textcolor{NavyBlue}{DROP},
		    {\textcolor{NavyBlue}{MOVE},
		    {\textcolor{NavyBlue}{SEE} e
		    {\textcolor{NavyBlue}{LOOK}.
		    
		    Sendo que 
		    {\textcolor{NavyBlue}{private static void action(RVM rvm,
		    String type)} guarda o tipo de comando passado da
		    pilha de dados, cria uma {\textcolor{NavyBlue}{Operação} 
		    op e verifica se essa operação é válida, caso seja, 
		    coloca na pilha de dados as informações necessárias 
		    que serão lançadas como resposta.
		    
		\subsubsection{ Tests.java }
		    Controla as funções que executam os comandos do
		    usuário e que são do tipo comparativas.
		    Entre elas, estão 
		    {\textcolor{NavyBlue}{CMP}, 
		    {\textcolor{NavyBlue}{EQ}, 
		    {\textcolor{NavyBlue}{NE}, 
		    {\textcolor{NavyBlue}{LE}, 
		    {\textcolor{NavyBlue}{LT},
		    {\textcolor{NavyBlue}{GE}, 
		    {\textcolor{NavyBlue}{GT}
		    que dão pop no topo da pilha de dados, duas vezes,
		    e compara os dois dados de acordo com a função
		    especificada. 
		    
		    Depois desse processo, é empilhado um dado do tipo
		    Num (que é um Stackable) na pilha de dados.
		    De tal forma que, caso a comparação seja verdadeira,
		    é empilhado um Num de conteúdo 1, caso contrário,
		    um Num de conteúdo 0. 
		
		\subsubsection{ Var.java }
		    Essa classe cuida dos comandos voltados a criação de
		    variáveis no programa do usuário. Tais como alocação
		    de memóiria, liberação de memória, receber e alterar
		    o valor da variável.
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{static void ALOC(RVM rvm, 
		    Stackable name)}
		    que recebe o nome da variável como parâmtro e 
		    verifica na RVM se não existe outra com outro nome.
		    Caso negativo, é criada uma variável com valor null.
		    
		    {\textcolor{NavyBlue}{static void FREE(RVM rvm, 
		    Stackable name)}
		    que remove a variável com o nome name da RVM.
		    
		    {\textcolor{NavyBlue}{static void SET(RVM rvm, 
		    Stackable name)}
		    que pega o valor do topo da pilha e armazena na
		    variável com o nome name, caso ela exista.
		    
		    {\textcolor{NavyBlue}{static void GET(RVM rvm, 
		    Stackable name)}
		    que pega o valor da variável e o coloca no topo da
		    pilha de dados.
		
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Scenario}
	    Nesse package, temos as classes que representam
	    os vários tipos de elementos contidos nocenários do 
	    jogo.
	    Para o controle desses elementos. usamos a interface
	    Scenario que além de padronizar o tipo de dado,
	    força todas as classes a terem uma função que
	    cuida dos danos adquiridos ao decorrer do jogo
	    (por exemplo, quando uma pedra é atacada por um robô,
	    ela perde vidas, e perdendo um determinado número de
	    vidas, ela é destruida.
	    
	    Dentre eles há a base, as rochas, árvores e água.
	    
		\subsubsection{ Base.java }
		    A base tem um número escolhido ao acaso (42) de
		    vidas, portanto, quando formos retornar o HP,
		    sempre será 42. Já que a base, ao ser atacada,
		    não recebe danos.
		    E ao imprimirmos uma base, teremos como resultado
		    "(ß) Base".
		
		\subsubsection{ Rock.java }
		    A pedra retira o dano recebido do seu HP(vida) e
		    o devolve quando é chamada a função que retorna o
		    HP.
		    E ao imprimirmos uma pedra, teremos como resultado
		    "(O) Rock".
		
		\subsubsection{ Scenario.java }
		    Interface que padroniza os diferentes tipos de
		    elementos do cenários em um tipo Scenario, além 
		    de padronizar a função que cuida dos danos 
		    recebidos por cada objeto.
		    
		    Tem-se as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ public int getHP() }
		    Retorna o número de vidas do presentes no robô.
		    
            {\textcolor{NavyBlue}{ public int takeDamage (int damage) }
            Essa é a função que cuida dos danos recebidos 
            pelo objeto, recebendo o dano como parâmetro
            para poder subtrair vidas do cenário.
		    
		\subsubsection{ Tree.java }
		    Assim como a pedra, a árvore recebe danos e os subtrai
		    de seu HP.
		    E quando a imprimimos através das funções IO, temos
		    "( ) Tree".
		    %"(♣) Tree". 
		
		\subsubsection{ Water.java }
		    A água, assim como a base, não recebe dano.
		    Portanto ela tem um número específico de HP
		    que se manterá intancto aos ataques sofridos.
		    Ao imprimirmos uma árvore, temos "( ) Water".
		    %"(≈) Water".
		    
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Stackable}
		Nesse package, temos a interface Stackable que
		será o tipo responsável pela atribuição da
		característica empilhável dos empilháveis.
		
		\subsubsection { Addr.java }
			Os objetos do tipo Addr são endereços de
			determinados valores em um vetor. Portanto
			são representados por inteiros.
			
			Nele encontramos as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Addr(int address) }
			que é o construtor de objetos do tipo Addr.
			
			{\textcolor{NavyBlue}{ public int getAddress() }
			que retorna o valor do endereço como um 
			inteiro.
		
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
		
		\subsubsection { Around.java }
			Tem como característica uma matriz de Strings
			que representam as direções as quais os robôs
			devem seguir para chegar aos determinados
			pontos visinhos.
			
			Nela, encontramos as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Around(Terrain[] seeing) }
   
    
    		{\textcolor{NavyBlue}{ public String[] indexToPosition
    		(int index) }
   			é responsável pelo retorno da String de coordenadas 
   			que o robô deve seguir para chegar a sua visinhança.
   			Ela recebe como parâmetro, o número de casas de 
   			distância que o robô pode atacar/ver.
		    
		    {\textcolor{NavyBlue}{ public void print() }
    		função para modo debuger!
    
		    {\textcolor{NavyBlue}{ public String toString() }
		    devolve a String "around", incluindo para saídas de IO.

		
		\subsubsection { Attack.java }
			Os objetos do tipo Attack são os tipos de
			ataque que o robô pode realizar. Por enquanto,
			temos o ataque MEELE que é a curta distancia(
			somente poderá atacar o que estiver nas casas
			visinhas a sua) ou RANGED que é a uma distância
			determinada pelas características do robô (caso
			o robo tenha um poder de atacar a 3 de distância,
			ele irá atingir o que está a até 3 casas de
			distância da sua).
			
			Nela, temos as seguintes funções:
					
			{\textcolor{NavyBlue}{ public Attack(String s) }
   			um construtor que monta o objeto a partir da
   			String passada.
			
			{\textcolor{NavyBlue}{ public String getAttack() }
			retorna o tipo de ataque em forma de String.
		
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.	
		
		\subsubsection { Direction.java }
			Os objetos do tipo Direction são do tipo que
			orientará os robôs na arena em relação a 
			movimentação e ataque. Pelo fato de a arena
			ser formada por bases hexagonais, temos as
			direções 
			{\textcolor{NavyBlue}{E}  (leste), 
			{\textcolor{NavyBlue}{NE} (nordeste), 
			{\textcolor{NavyBlue}{NW} (noroeste),
			{\textcolor{NavyBlue}{W}  (oeste), 
			{\textcolor{NavyBlue}{SW} (sudoeste) e 
			{\textcolor{NavyBlue}{SE} (sudeste).
			Sempre que um objeto do tipo Direction for
			chamado pelo usuário, este deve ser retratado
			com o símbolo 
			{\textcolor{NavyBlue}{''->''}
			antes do seu conteúdo.
			
			Por exemplo, 
			{\textcolor{NavyBlue}{''->WE''}.
			
			A classe Direction possui armazenará o movimento
			como uma matriz de coordenadas, que terá
			determinados tipos de movimento quando o robô 
			estiver em uma linha par e outro tipo de movimento
			quando o mesmo estiver numa linha ímpar.
			Essas coordenadas são dadas de modo que, quando
			a somamos com as coordenadas do robô, ele se 
			movimentará para o local desehjado.
			Obs.: Quando a linha é par, usamos a 1ª linha da
			matriz, caso contrário, usamos a 2ª.
			
			Temos as funções:
			
			public Direction(String dir)
			que é o contrutor
			
			{\textcolor{NavyBlue}{ public Direction(int move, 
			int dir) } 
			que recebe a direção e a partir dela, preenche a matriz 
			com as respectivas direções.
			
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			static void ALOC(RVM rvm, Stackable name)
			{\textcolor{NavyBlue}{ public int[] get(int row) }
			Devolve um vetor com a direção a ser seguida, se
			a linha em que ele está for par, devolvemos a
			"( ) Tree".
			%"(♣) Tree".
			1ª linha da matriz, caso contrário, a 2ª.
			
			{\textcolor{NavyBlue}{  private void set(int even\_x, 
			int even\_y, int odd\_x, int odd\_y) }
			preenche a matriz com as direções que são recebidas
			como parâmetro.
		
		\subsubsection { Item }
			Item não é uma classe, é uma pasta com as 
			classes que representam objetos do tipo item
			(implementam a interface de itens),
			o tipo item é um empilhável que pode ser pego
			e destruído pelo robô.
			Dentre elas, temos a
			 
			{\textcolor{NavyBlue}{Crystal.java}
			 que é repsonsável pela criação de
			objetos cristais.
			
			a {\textcolor{NavyBlue}{Item.java}
			que é uma interface responsável pela atribuição 
			do tipo item às classes.
			
			e a {\textcolor{NavyBlue}{Stone.java} que é 
			responsável pela criação das pedras que são 
			destruíveis e colecionáveis pelos robôs.
			 
		\subsubsection { Num.java }
			É um empilhável do tipo número.
			Ela possui as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Num(double num) }
			que é o construtor, que cria o objeto usando
			um parametro numérico que é recebido.
    
    		{\textcolor{NavyBlue}{ public double getNumber() }
 	  		que retorna o valor de Num em formato double.
  
    		{\textcolor{NavyBlue}{ public String toString()}
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			
		\subsubsection { Stack.java }
			Essa classe administra as pilhas do programa,
			controlando informações sobre onde está o seu 
			topo ou qual o seu tamanho.
			
		\subsubsection { Stackable.java }
			É a interface Stackable que se responsabiliza
			pelos objetos empilháveis. Essa interface não
			possui características exclusivas como funções
			e variáveis que seriam herdadas pelas classes
			desse tipo, é apenas para generalizar o tipo
			dos empilháveis.
			
		\subsubsection { Text.java }
			É criado o tipo de Stackable Text, onde 
			poderemos empilhar um texto ou String.
			Possui as seguintes funções:
			
			{\textcolor{NavyBlue}{public String getText() }
			que retorna o texto em si em formato String.
			
    		{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.


\end{document}
