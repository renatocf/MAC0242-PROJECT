\documentclass[a4paper]{article}

% Linguagem
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}

% Pacotes matemáticos
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

% Fontes e identaçãp
\usepackage{setspace}                   % espaçamento flexível
\usepackage{indentfirst}                % indentação do primeiro parágrafo
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

% Pacotes para cores e modelos
\usepackage[a4paper,top=3.0cm,bottom=2.0cm,left=3.0cm,right=2.0cm]{geometry} \usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,
            colorlinks=true,citecolor=DarkGreen,linkcolor=DarkRed,
            urlcolor=DarkRed,filecolor=DarkGreen,
            bookmarksopen=true]{hyperref}

% Pacotes para itens
\usepackage{calc}  
\usepackage{enumitem}  

\title  {Projeto de Laboratório de Programação II - Fase 1}
\author {Karina Suemi, Vinícius Silva, Renato Cordeiro}
\date   {}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Introdução} \label{sec:introdução}

    Nesta fase inicial, o projeto consiste em criar um leitor e 
    interpretador de comandos em linguegem de máquina. O principal 
    objetivo destes é servir como núcleo da futura classe responsável 
    pelos robôs.
    
    \subsection{Projeto}
    
    Os arquivos estão separados de acordo com a seguinte estrutura de
    diretórios:
    \begin{itemize}
        \item \textbf{bin:}  Arquivo executável principal do programa;
        \item \textbf{doc:}  Pasta para a documentação, com este arquivo 
                             e a versão fonte em \LaTeX;
        \item \textbf{lib:}  Arquivos com classes/pacotes de Perl 
                             no formato \texttt{.pm};
        \item \textbf{test:} Arquivos de teste com código em Assembly
                             do montador/máquina virtual \texttt{.txt}.
    \end{itemize}
    
    \subsection{Estrutura}
      
        Para informações sobre o uso de programa e os seus 
        desenvolvedores, consultar os arquivos \href{run:../README.md}
        {\texttt{README.md}} e \href{run:../LICENSE}{\texttt{LICENSE}}.
        
        O programa consiste de três partes principais:
        \begin{itemize}
            \item \hyperref[sec:montador]        {Montador};
            \item \hyperref[sec:maquina_virtual] {Máquina Virtual};
            \item                                 Emulador.
        \end{itemize}
    
    \subsection{Emulador}
    
        O emulador é a parte mais simples do programa, e consiste de 
        um arquivo do tipo \texttt{.pl} nomeado 
        \href{run:../bin/robots.pl}{\texttt{robots.pl}} na pasta
        \texttt{bin/}. Para executá-lo, basta rodar o programa 
        passando como parâmetro na linha de comando um arquivo (de 
        extensão qualquer) com o assembly válido. 
        
        Caso haja erro de compilação, o programa será encerrado antes 
        da execução de qualquer comando. Caso o erro seja lógido 
        (\emph{runtime}), os erros serão impressos na saída de erros 
        (STDERR) no próprio prompt de comando.

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Montador} \label{sec:montador}

    O montador tem como função ler o programa em texto (que será 
    passado pelo usuário), ver se ele está formatado de maneira 
    correta e em caso positivo, é criada uma matriz 3 x n, sendo $n$ 
    o número de comandos, que será passada para a Máquina Virtual.
    
    O arquivo com o montador está no diretório de bibliotecas 
    \texttt{lib/} e é chamado \href{run:../lib/Cortex.pm}
    {\texttt{Cortex.pm}}
    
    \bigskip\bigskip
    
    No caso, as linhas do programa de entrada terão que seguir o 
    seguinte padrão:

    \begin{center}
        \textbf{[ Comando, Argumento, Label ]}
    \end{center}
    
    O montador devolverá erro em caso de comandos que não sejam 
    compatíveis com seus respectivos tipos de argumentos. No caso da
    entrada ser: 
    
    \begin{description}
    [leftmargin=!,labelwidth=\widthof{\bfseries The longest label}]

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        \item [\textbf{\textcolor{red}{x}} "ADD Olá"] 
        O comando ADD não deveria receber argumentos, e como não é o 
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "ADD"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "PUSH Oie!"] 
        O comando PUSH deveria receber argumentos numéricos, e como não é 
        o caso, o programa passará \emph{undef} para a Máquina Virtual.
    
        \item [\textcolor{green}{\checkmark} "PUSH 100"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "JIF 5uvas"] 
        O comando JIF deveria receber argumentos em forma de texto (pode
        conter números, desde que não sejam 1º caracter), e como não é o
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "JIF uvas5"] 
        Este seria o correto.

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \end{description}

    \bigskip\bigskip

    Segue a tabela com os argumentos necessários para cada tipo de 
    comando:
    
    \begin{center}
      \begin{tabular}{|c|l|rc|}
          Vazio     &  ADD - DIV - DUP - END - EQ - GE - GT - 
                       LE - LT - MUL - NE - POP - PRN - SUB   \\
          Numérico  &  PUSH - RCL - STO - JMP - JIT - JIF     \\
          String    &  JIF - JIT                              \\
      \end{tabular}
    \end{center}  
    
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
\section{Máquina Virtual} \label{sec:maquina_virtual}
    
    A máquina virtual (RVM, \emph{Robot Virtual Machine}, consiste em 
    um conjunto de módulos localizados no diretório lib/RVM que integram 
    o pacote/classe RVM. 
    
    Os arquivos do módulo são:
    \begin{itemize}
        \item \href{run:../lib/RVM/RVM.pm}       {RVM.pm        }
        \item \href{run:../lib/RVM/Overload.pm}  {Overload.pm   }
        \item \href{run:../lib/RVM/ctrl.pm}      {ctrl.pm       }
        \item \href{run:../lib/RVM/functions.pm} {functions.pm  }
        \item \href{run:../lib/RVM/f\_arit.pm}   {f\_arit.pm    }
        \item \href{run:../lib/RVM/f\_io.pm}     {f\_io.pm      }
        \item \href{run:../lib/RVM/f\_jumps.pm}  {f\_jumps.pm   }
        \item \href{run:../lib/RVM/f\_memo.pm}   {f\_memo.pm    }
        \item \href{run:../lib/RVM/f\_stk.pm}    {f\_stk.pm     }
        \item \href{run:../lib/RVM/f\_tests.pm}  {f\_tests.pm   }
    \end{itemize}
    
    \subsection{RVM.pm}
        
        A \emph{Robot Virtual Machine} (\textbf{RVM}) é o pacote 
        principal que controla o 'cérebro' dos robôs, servindo como o
        interpretador para o formato criado pelo montador. Cada 
        instância da classe RVM possui os seguintes atributos:
        
        \begin{itemize}
            
            \item PROG:  Vetor com os comandos do programa, conforme
                         o formato criado pelo montador;
            \item DATA:  Vetor com a pilha principal de memória, no 
                         qual serão armazenados os dados colocados 
                         com comandos de manipulação da pilha;
            \item PC:    Registrador para a posição atual de execução 
                         dos comandos dentro do vetor PROG;
            \item RAM:   Memória auxiliar, a ser utilizada para funções;
            \item CTRL:  Vetor de controle dos retornos das funções 
                         (callbacks);
            \item LABEL: Hash com as posições associadas a cada LABEL
                         criado como marcador no código da RVM.
            
        \end{itemize}
        
        O módulo RVM contém dois métodos, responsáveis por agirem como
        construtor (\textbf{new}) e inicializador de programa 
        (\textbf{upload}) para os objetos da RVM.
        
    \subsection{Overload.pm}
        
        Módulo auxiliar que faz parte da classe da RVM. Sua principal
        função é fornecer a sobrecarga do operador \emph{double quote}
        (\textbf{qq//} ou \textbf{"}), de modo a possibilitar a 
        impressão dos valores armazenados dentro da RVM.
    
    \subsection{ctrl.pm}
    
        O módulo auxiliar do controlador contém o método responsável 
        por realizar a execução do programa armazenado no atributo 
        \textbf{PROG} do objeto da classe RVM. 
        
        Começando da posição 0, a cada posição de PROG realiza a 
        chamada da função correspondente, usando os argumentos (se 
        disponíveis ou necessários). Nesse processo, atualiza o PC 
        (registrador de posição) para realizar a atualização 
        necessária (avançar para o próximo comando ou fazer um desvio).
        
        Quando a função retorna um erro, lança uma exceção (erro de 
        \emph{runtime}), que pode ser de 3 tipos:
        \begin{itemize}
            
            \item Falha de segmentação: tentativa de acessar região 
                                        não definida da memória -
                                        overflow/underflow da
                                        pilha de dados DATA;
                                        
            \item Operação inválida:    quando o operando não é do tipo 
                                        válido;
                                        
            \item Label desconhecido:   o LABEL acessado pelo comando 
                                        de controle de \emph{workflow} 
                                        não foi definido.
                                        
        \end{itemize}
        
    \subsection{functions.pm}
        
        Módulo auxiliar que reúne as funções criadas em outros módulos 
        da Máquina Virtual. Com ele é possível ter acesso às funções 
        que podem ser executadas pela RVM.        
        
        Para cada comando implementado nos módulos listados, as funções
        recebem como argumento o objeto do pacote sobre o qual a ação 
        deve ser realizada, o argumento (se não existir, é \emph{undef},
        e é descartado) e o número de elementos da pilha.
        
        Todas as funções retornam a atualização do número de elementos
        da pilha, estritamente maior que 0, ou números negativos, 
        indicando as exceções listadas na seção anterior.

    \subsection{f\_arit.pm}
        
        O f\_arit.pm contém as funções aritméticas que o programa deve
        executar, como a soma, subtração, multiplicação e divisão.
        
        Ele desempilha o último e penúltimo valores a partir do topo 
        da pilha de dados. Caso não existam dois valores, a função 
        lança uma exceção.
        
        \textbf{Observação}: As 4 operações funcionam de maneira
        análoga.        
        
    \subsection{f\_io.pm}
        
        Este módulo é responsável pela execução da função PRN 
        (\emph{PRiNt}), que imprime na STDOUT o valor do topo da 
        pilha de dados.
            
    \subsection{f\_jumps.pm}
        
        O f\_jumps.pm contém as funções responsáveis pela execução dos
        comandos associados a jumps, como JMP (\emph{JuMP}), JIT 
        (\emph{Jump If True})e JIF (\emph{Jump If False}).
        
        No caso de \emph{JMP}, este irá atribuir o argumento passado 
        ao registrador de instrução (PC), realizando um salto 
        incondicional a esta posição. Caso não existam instruções
        na posição indicada, lança uma exceção do tipo \emph{Falha
        de Segmentação}.
        
        Para os outros comandos de salto condicional (\emph{JIT}/
        \emph{JIF}), também é possível passar como argumento um
        LABEL. Caso esta posição não exista, lança uma exceção
        específica.
    
    \subsection{f\_memo.pm}
        
        O f\_memo.pm  contém as funções que mexem com endereçamento
        de memória: \emph{STO} e \emph{RCL}.
        
        Este módulo é o responsável por realizar a transferência de
        dados entre o vetor de memória principal (DATA) e o vetor 
        auxiliar (RAM). Cada um deles recebe como argumento o endereço
        (posição do vetor), de modo que:
        \begin{itemize}
            
            \item STO: retira o valor de DATA e coloca na posição 
                       \$arg de RAM;
            \item RCL: realiza o processo inverso.
            
        \end{itemize}
        
        Ambas as funções devolvem uma exceção do tipo \emph{Falha de
        Segmentação} caso não haja elementos em DATA (\emph{STO}) ou 
        na posição de RAM (\emph{RCL}).
        
    \subsection{f\_stk.pm}
        
        O submódulo f\_stk.pm contém as funções de manipulação de pilha.
        \emph{PUSH}, \emph{POP} e \emph{DUP}.
        \begin{itemize}
            
            \item PUSH: Recebe um argumento e o coloca no topo da pilha 
                        de dados DATA;
            
            \item POP:  Retira o dado que estiver no topo da pilha de 
                        dados; 
            
            \item DUP:  Empilha uma cópia do topo da pilha.
        
        \end{itemize}
        
    \subsection{f\_tests.pm}
            
        O submódulo f\_tests.pm armazena as funções lógicas. Cada uma
        dekas retira os dois elementos do topo da pilha e, em seguida,
        realiza uma comparação, usando como primeiro argumento o topo
        da pilha.
        
        Considerando 'A' o topo da pilha e 'B' o elemento anterior,
        os comandos realizam as seguintes ações, em seus análogos 
        para números:
        \begin{itemize}
            \item EQ: A == B
            \item GT: A >  B
            \item GE: A >= B
            \item LT: A <  B
            \item LE: A <= B
            \item NE: A != B
        \end{itemize}
    
\end{document}
