\documentclass[a4paper]{article}

% Linguagem
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}

% Pacotes matemáticos
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

% Fontes e identaçãp
\usepackage{setspace}                   % espaçamento flexível
\usepackage{indentfirst}                % indentação do primeiro parágrafo
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

% Pacotes para cores e modelos
\usepackage[a4paper,top=3.0cm,bottom=2.0cm,left=3.0cm,right=2.0cm]{geometry} \usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,
            colorlinks=true,citecolor=DarkGreen,linkcolor=DarkRed,
            urlcolor=DarkRed,filecolor=DarkGreen,
            bookmarksopen=true]{hyperref}

% Pacotes para itens
\usepackage{calc}  
\usepackage{enumitem}  

\title  {Projeto de Laboratório de Programação II - Fase 2}
\author {Karina Suemi, Vinícius Silva, Renato Cordeiro}
\date   {}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Introdução} \label{sec:introdução}

    Nesta fase, o projeto consiste na criação de uma máquina
    virtual em JAVA, juntamente com a implementação de funções
    que darão ao usuário o poder de controlar o robô através 
    de comandos usados com pilha de dados.
    Há também a criação da Arena, esta é resposável por controlar
    os robôs de forma que eles sejam impossibilitados de fazer
    movimentos não propícios. 
    
    E por último, temos os tipos de terrenos e objetos que estarão
    dispostos nele, como cristais, rochas ( como objetos ), bases, 
    água, árvores, entre outros ( como cenário ). 
    
    
    \subsection{Projeto}
    
    Os arquivos estão separados de acordo comcolor a seguinte estrutura de
    diretórios:
    \begin{itemize}
        \item \textbf{bin:}  Arquivo executável principal do programa;
        \item \textbf{doc:}  Pasta para a documentação, com este arquivo 
                             e a versão fonte em \LaTeX;
        \item \textbf{lib:}  Arquivos com classes/pacotes de Perl 
                             no formato \texttt{.pm};
        \item \textbf{src:}  Pasta que contém os cógigos-fonte em JAVA,
        					 separados e organizados por pastas.
        \item \textbf{test:} Arquivos de teste com código em Assembly
                             do montador/máquina virtual \texttt{.txt}.
    \end{itemize}
    
    \subsection{Estrutura}
      
        Para informações sobre o uso de programa e os seus 
        desenvolvedores, consultar os arquivos \href{run:../README.md}
        {\texttt{README.md}} e \href{run:../LICENSE}{\texttt{LICENSE}}.
    

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Montador} \label{sec:montador}

    O montador tem como função ler o programa em texto (que será 
    passado pelo usuário), ver se ele está formatado de maneira 
    correta e em caso positivo, é criada uma matriz 3 x n, sendo $n$ 
    o número de comandos, que será passada para a Máquina Virtual.
    
    O arquivo com o montador está no diretório de bibliotecas 
    \texttt{lib/} e é chamado \href{run:../lib/Cortex.pm}
    {\texttt{Cortex.pm}}
    
    \bigskip\bigskip
    
    No caso, as linhas do programa de entrada terão que seguir o 
    seguinte padrão:

    \begin{center}
        \textbf{[ Comando, Argumento, Label ]}
    \end{center}
    
    O montador devolverá erro em caso de comandos que não sejam 
    compatíveis com seus respectivos tipos de argumentos. No caso da
    entrada ser: 
    
    \begin{description}
    %[leftmargin=!,labelwidth=\widthof{\bfseries The longest label}]

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        \item [\textbf{\textcolor{red}{x}} "ADD Olá"] 
        O comando ADD não deveria receber argumentos, e como não é o 
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "ADD"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "PUSH Oie!"] 
        O comando PUSH deveria receber argumentos numéricos, e como não é 
        o caso, o programa passará \emph{undef} para a Máquina Virtual.
    
        \item [\textcolor{green}{\checkmark} "PUSH 100"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "JIF 5uvas"] 
        O comando JIF deveria receber argumentos em forma de texto (pode
        conter números, desde que não sejam 1º caracter), e como não é o
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "JIF uvas5"] 
        Este seria o correto.

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \end{description}

    \bigskip\bigskip

    Segue a tabela com os argumentos necessários para cada tipo de 
    comando:
    
    \begin{center}
      \begin{tabular}{|c|l|rc|}
                     &  ADD - DIV - DUP - END - EQ - GE - GT   \\
          Vazio      &  MOD - LE - LT - MUL - NE - POP - PRN   \\
                     &  SUB - RET - MOVE - DRAG - DROP - HIT   \\
                     &  LOOK - ITEM - SEE - SEEK               \\
                     &										   \\
          Numérico   &  RCL - STO                              \\
          			 &										   \\
          String     &  JMP - JIF - JIT - CALL                 \\
          			 &										   \\
          Empilhável &  crystal - stone                        \\
      \end{tabular}
    \end{center}  
    
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 
\section{Packages}
	Foram criados pacotes para facilitar a divisão
	e entendimento do código.
	
	\subsection{Arena}
		O package "Arena" cuida das classes que envolvem os
		terrenos e a arena em si, bem como o classe que cuida
		da autorização de execução de determinadas funções que
		necessitam da consultoria da arena para serem executadas.
		
		\subsubsection{ Action.java }
		    Aqui é onde encontramos a implementação das funções
		    utilizadas diretamente pelos robôs, tais como 
		    {\textcolor{NavyBlue}{HIT},
		    {\textcolor{NavyBlue}{DRAG},
		    {\textcolor{NavyBlue}{DROP},
		    {\textcolor{NavyBlue}{MOVE},
		    {\textcolor{NavyBlue}{SEE} e 
		    {\textcolor{NavyBlue}{LOOK}.
		    
		    e tratamos a saída de modo que os dados que sejam 
		    emitidos na pilha ao usar a função, são devolvidos em
		    um vetor de Stackables. 
		    Caso a função só lance uma String como saída, essa 
		    String será passada para tipo Text e preencherá a 
		    primeira casa do vetor de Stackables.
		    
		    O restante das funções são auxiliares, que devolvem
		    os respectivos resultados de cada função
		    
		\subsubsection{ Appearence.java }
		    É uma estrutura chamada Enum, onde dizemos que as
		    aparências podem ser somente as mostradas a seguir:
		    {\textcolor{NavyBlue}{DIRT},
            {\textcolor{NavyBlue}{GRASS},
            {\textcolor{NavyBlue}{ROCKY},
            {\textcolor{NavyBlue}{ICE},
            {\textcolor{NavyBlue}{WATER},
            {\textcolor{NavyBlue}{SAND},
            {\textcolor{NavyBlue}{JUNGLE} e
            {\textcolor{NavyBlue}{TUNDRA}.
		
		\subsubsection{ Map.java }
		    A classe mapa vai cuidar da matriz de terrenos, e 
		    podemos assumir que cada mapa terá um clima diferente.
		    
		    É nessa classe que também criamos os times a partir
		    do parâmetro número do time passado, onde temos uma 
		    matriz representando jogadores de determinado time.
		    
		    Também inserimos exércitos e removemos Scenários.
		    Como nas seguintes funções:
		    
		    {\textcolor{NavyBlue}{public Scenario
		    removeScenario(int i, int j)}
		    que eliminará os Scenários do terreno com as coordenadas
		    passadas como parâmetro. Essa função serve para o caso 
		    de termos ataque a árvores e até mesmo a morte de robôs,
		    já que estes também são do tipo Scenario.
		    
		    {\textcolor{NavyBlue}{public Robot insertArmy(String
		    name, int player, int ID, int i, int j, String pathToProg)}
            que irá inserir um robô de acordo com os parâmetros
            recebidos, como nome do robô, a qual jogador ele pertence,
            o seu ID e as suas coordenadas.
            Essa função irá criar esse robô e implementá-lo no como 
            um Scenario nas coordenadas indicadas da arena.
		    
		\subsubsection{ Robot.java }
			Essa classe é a que define as características dos robôs
			em geral, como velocidade ro robô, vida, quantos danos ele
			causa, entre outras.
			
			Dentre suas funções, temos o contrutor que recebe determinadas
			características e cria um robô, têm também a
			 
			{\textcolor{NavyBlue}{public Item removeSlots(int position)}
			que remove o robô de determinado terreno, a
			
			{\textcolor{NavyBlue}{public void identify()}
			que imprime as características principais do robô,
			
			{\textcolor{NavyBlue}{public void run()}
			executa o programa, acrescentando 1 no PC,
			
			{\textcolor{NavyBlue}{public void upload(Vector<Command> PROG)}
			carrega um novo programa e 
			
			{\textcolor{NavyBlue}{public int takeDamage(int damage)}
			que, por ser um Scenario, remove das vidas do robô o dano 
			sofrido.
			
			E quando imprimimos um determinado robô, é devolvida uma
			String com o nome dele. Além de possuir também os getters
			e setters de determinadas características.
			
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		\subsubsection{ RobotList.java }
			Ele cuida dos exércitos de robôs de tal forma
			a possuir um vetor de robôs e conseguir controlar
			seus movimentos e suas respectivas ordens.
			
			Para que possamos fazer com que os robôs mais velozes
			cheguem antes dos menos velozes, usamos a função quick 
			sort que compara velocidades de robôs, onde esta 
			ordenará a velocidade dos respectivos robôs e passará 
			para o programa, a ordem certa de movimentação.
			
			Funções como a de manutenção dos exércitos também são
			encontradas nessa classe, como a de adição e remoção
			de um robô dentro de determinado exército.
		
		\subsubsection{ Terrain.java }
		    Cada terrain é um empilhável e possui um tipo de 
		    rugosidade, uma aparência e possivelmente um
		    Scenario.
		    
		    A maioria de suas funções, além do construtor ( que
		    irá receber a aparência e a partir dela, determinar 
		    o tipo de rugosidade ), tem-se basicamente getters,
		    setters e removedores de características da classe.
		    É válido lembrar que utilizamos polimorfismo para o
		    cnstrutor dessa classe, pois há vários tipos dessa
		    função que recebem diferentes tipos e números de
		    argumentos.
		    
		
		\subsubsection{ Type.java }
		    Assim como em Appearence, type também é um Enum, só
		    que dessa vez, representa os tipos de terreno da
		    arena. Sendo eles, por enquanto:
		    {\textcolor{NavyBlue}{NORMAL} e 
            {\textcolor{NavyBlue}{ROUGH}.
		
		\subsubsection{ Weather.java }						
		    Assim como Appearence e Type, Weather é do tipo Enum,
		    representando desta vez. os vários tipos de clima da
		    arena. Sendo eles:
		    
		    {\textcolor{NavyBlue}{CONTINENTAL},
            {\textcolor{NavyBlue}{ARTICAL},
            {\textcolor{NavyBlue}{DESERTIC} e
            {\textcolor{NavyBlue}{TROPICAL}.
		
		\subsubsection{ World.java }				
			World é uma parte mais global do programa que cuida das 
			características do jogo em geral, como número de 
			jogadores, tempo, o mapa, entre outros.
			É uma classe única, já que só teremos um único mundo
			para cada partida.
			
			Nela temos as funções que controlam a inserção e 
			remoção de exércitos, além da função que controla os
			timesteps (tempos ) e também cuisa do modo Debugger.
		
		
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
		
				
	\subsection{Exception}
		O package "Exception" cuida dos lançamentos de exceção
		que o programa gera para erros no código que será recebido
		do usuário.

		Como por exemplo as exceções de falha de segmentação,
		operações inválidas, erros de tipo, variáveis não
		inicializadas, entre outros.
		
		As classes desse package são chamadas pelas outras classes
		que utilizam essa forma de mandar exceção.
		 
	\subsection{Operation}
		\subsubsection{ Operation.java }
			Essa classe é um meio de comunicação entre a arena e a RVM,
			pois ela manda como retorno a resposta da função, se ela pode
			ou não pode ser realizada.
			
			Para a sua construção, ela necessita receber a RVM, juntamente
			com a ação que o robô deseja realizar.
			
	
	\subsection{Parameters}
		\subsubsection{ Debugger.java }
			Essa classe irá auxiliar no encontro dos erros do cógigo,
			pois mostra passo a passo, como o programa do usuário
			está sendo lido e interpretado.
			
		
		\subsubsection{ Game.java     }
		    É uma interface que detém as características do jogo 
		    que serão passadas para muitas outras classes.
		    Tais como a velocidade da animação, o tamanho do mapa,
		    o número máximo de robôs, entre outras.
		    
		    Ela foi criada para ter um amior controle das 
		    características configuracionais do jogo e caso
		    necessitem ser alteradas, todas estarão no mesmo lugar.
		    
		
	\subsection{Parser}
		\subsubsection{ Parser.java }
		    O parser recebe um vetor de trincas (comando, argumento,
		    label), analisa as variáveis conforme o tipo correspondente 
		    no java e monta uma classe com o mesmo nome do programa em 
		    assembly.
		    
		    Adicionalmente, o programa cria um arquivo "Parser.xml"
		    para ser rodado pelo Ant e compilar todos os códigos no
		    diretório do package.
				
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Random}
	    Aqui criamos os mapas de determinados cenários,
	    gerados de forma probabilística, de modo que
	    o mesmo cenário se altere de acordo com a semente
	    passada. Cada cenário usa os tipos Scenario que são
	    os elementos que compõe os cenários.
	    
		\subsubsection{ CalmField.java }
		    Gera um cenário com árvores, rochas, pedras e 
		    cristais no terreno de forma probabilística.
		    Não podemos esquecer que ela gera as bases
		    necessárias para cada time.
		    
		\subsubsection{ Desert.java }
		    Gera um cenário com rochas, pedras, cristais e
		    bases de uma forma aleatoriezada e tenha as
		    características de um deserto.
		    
		\subsubsection{ Jungle.java }
		    Gera um cenário com árvores, rochas, pedras,
		    cristais e bases. Também possui um rio gerado
		    e distribuido probabilisticamente em meio a 
		    arena. 
		    
		    Esse rio possui partes de água mais rasas
		    e outras mais profundas, são as chamadas
		    deep water e water respectivamente.
		
		\subsubsection{ RamdomMap.java }
    		É responsável pela geração do mapa. Recebe 
    		parâmetros indicando qual será o tipo de
    		clima e os associa com o respectivo tipo
    		de mapa.
    		
    		Em sua outra função, ela gera o mapa, colocando
    		os determinados símbolos nos seus terrenos.
    		
		\subsubsection{ Theme.java }
		    Essa é uma interface que padroniza todos os 
		    tipos de temas, como JUNGLE, DESERT e WINTER.
		    Esse tipo de dado possui uma função específica
		    que retorna uma matriz representando o mapa
		    criado. 
		
		\subsubsection{ Winter.java }
		    Gera um cenário com árvores, rochas, pedras, 
		    cristais e bases de forma aleatória. Além de
		    gerar um rio congelado (água) no centro da arena.
		    

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Robot}
	    Esse package cuida das funções atreladas aos robôs
	    si, entre elas está a RVM e as funções que interpretam
	    os comandos utilizados pelos usuários.
	    
		\subsubsection{ Arit.java }
		    Essa classe controla as funções que interpretam
		    os comandos aritméticos que o usuário passar na
		    pilha de comandos, como por exemplo: Soma,
		    subtração, divisão, Multiplicação e Resto.
		    Tudo isso é manipulado na pilha de dados,
		    recebemos os valores de lá, e mandamos a resposta
		    para o topo da mesma.
		    
		    Temos a seguinte função:
		    
		    {\textcolor{NavyBlue}{ private static final void 
		    calculate(RVM rvm, Operation op) }
		    que cuida da generalização do trabalho realizado 
		    na pilhaEssa classe controla as funções que interpretam
		    os comandos aritméticos que o usuário passar na
		    pilha de comandos, como por exemplo: 
		    {\textcolor{NavyBlue}{ADD} ( Soma ),
		    {\textcolor{NavyBlue}{SUB} ( Subtração),
		    {\textcolor{NavyBlue}{DIV} ( Divisão ), 
		    {\textcolor{NavyBlue}{MUL} ( Multiplicação ) e 
		    {\textcolor{NavyBlue}{MOD} ( Resto ).
		    Tudo isso é manipulado na pilha de dados,
		    recebemos os valores de lá, e mandamos a resposta
		    para o topo da mesma. de dados pelas funções aritméticas.
		        
		\subsubsection{ Check.java }
		    Essa função tem como objetivo checar o terreno em
		    si e sua visinhança, bem como 
		    
		    {\textcolor{NavyBlue}{  static void ITEM(RVM rvm) }
		    que dá um pop na pilha caso o topo seja um terreno
		    e empilha os itens contidos nesse terreno na pilha
		    de dados.
		    
		    {\textcolor{NavyBlue}{  static void SEEK(RVM rvm) }
		    que verifica se o topo é um Stackable e desempilha
		    , depois verifica se o topo é um Around, e desempilha.
		    Depois, percorre a visinhança do próprio robô 
		    (que dependerá do quão longe o robô enxerga)
		    e tenta encontrar Items nessa visinhança.
		    
		    Isso auxilia quando o robô for procurar cristais,
		    por exemplo, fazendo com que ele não precise estar
		    necessariamente na casa do cristal para notar a 
		    sua presença.
		    
		\subsubsection{ Command.java }
		    Cria objetos do tipo comando, para serem manipulados
		    da mesma forma na pilha de comandos.
		    Tem como parâmetros o próprio comando, os argumentos
		    do tipo Stackable e a label que caracterizam as linhas
		    passadas pelo usuário no programa que o mesmo cria em
		    baixo nível.
		    Na classe, também temos as funções básicas getters e
		    setters de determinadas características de cada
		    comando.
		    
		\subsubsection{ Ctrl.java }
		    É um comunicador que interpreta um comando do programa
		    do usuário em forma de String (por exemplo: "JMP") e 
		    chama a respectiva função, passando os seus parâmetros 
		    para ela.
		    
		    Dentre esses comandos que ela interpreta, estão também
		    aqueles que podem ser executados pelos robôs, como
		    {\textcolor{NavyBlue}{MOVE}, 
		    {\textcolor{NavyBlue}{HIT}, 
		    {\textcolor{NavyBlue}{DRAG}, 
		    {\textcolor{NavyBlue}{DROP}, 
		    {\textcolor{NavyBlue}{SEE} e 
		    {\textcolor{NavyBlue}{LOOK}.
		    
		\subsubsection{ Func.java }
		    É responsável pelas funções CALL e RET que controlam
		    o valor do PC quando comandos do tipo Jump são
		    executados.
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ static void CALL(RVM rvm, 
		    Stackable arg) }
		    Atualiza o PC para o valor que foi solicitado pelo
		    por algum dos tipos de Jump, esse valor pode ser
		    tanto uma label quanto um número que representa
		    a linha do programa criado pelo usuário.
		    
		    {\textcolor{NavyBlue}{ static void RET(RVM rvm) }
		    Essa função trabalha em conjunto com o CALL,
		    já que ela recupera o valor que o PC tinha antes de
		    ser alterado pelo próprio CALL.
		
		\subsubsection{ IO.java }
		    Essa classe controla as funções que interpretam
		    os comandos IO (Input/Output) que o usuário 
		    passar na pilha de comandos, que no caso, só
		    temos o print (
		    {\textcolor{NavyBlue}{ static void PRN(RVM rvm) }
		    ). 
		    
		    Nessa função, desempilhamos o topo da pilha e
		    imprimimos seu valor.
		
		\subsubsection{ Jumps.java }
		    Assim como as classes Arit e IO, essa classe
		    também executa os comandos passados pelo usuário,
		    só que, desta vez, com funções Jump. Como o 
		    {\textcolor{NavyBlue}{JIT}  (Jump If True), 
		    {\textcolor{NavyBlue}{JIF}  (Jump If False), 
		    {\textcolor{NavyBlue}{JMP}  (JuMP) e
		    {\textcolor{NavyBlue}{JCMP} (Jump CoMPare),
		    atuando de tal forma que
		    o PC é atualizado para o endereço passado.
		    
		\subsubsection{ Mem.java }
		    Da mesma forma que algumas classes anteriores, essa
		    função cuida dos comandos passados pelo usuário.
		    Sendo esses comandos, formas de controlar o
		    armazenamento e recuperação de dados na memória.
		    
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ static void STO(RVM rvm, 
		    Stackable position) }
		    que armazena o que está no topo da pilha de dados,
		    na memória de acordo com o parâmetro recebido, que
		    representa o endereço de memória em que se deseja
		    ser salvo o dado. E após esse processo, retira o
		    dado da pilha de dados.
		    
		    {\textcolor{NavyBlue}{ static void RCL(RVM rvm, 
		    Stackable position) }
		    que recupera o que foi armazenado em um determinado
		    endereço de memória, que é passado pelo usuário como
		    parâmetro, e joga esse dado na pilha de dados.
		    
		\subsubsection{ Prog.java }
		    Controla as funções que não tem uma função específica
		    no programa, como o END (que não faz mais nada além de
		    finalizar o programa) e NOPE (que não realiza nada).
		    
		    Em: {\textcolor{NavyBlue}{ static void END(RVM rvm) }}
		    atualizamos o PC para -1 (local onde não há nenhum
		    outro comando) o que faz com que o programa seja
		    finalizado.
		    
		\subsubsection{ RVM.java }
			A \emph{Robot Virtual Machine} (\textbf{RVM}) é a classe 
        	principal que controla o 'cérebro' dos robôs, servindo como o
		    interpretador para os comandos interpretados. Cada 
		    instância da classe RVM possui os seguintes atributos:
		    
		    \begin{itemize}
		        
		        \item PROG:  Vetor com os comandos do programa, conforme
		                     o formato criado pelo montador;
		        \item DATA:  Vetor com a pilha principal de memória, no 
		                     qual serão armazenados os dados colocados 
		                     com comandos de manipulação da pilha;
		        \item PC:    Registrador para a posição atual de execução 
		                     dos comandos dentro do vetor PROG;
		        \item RAM:   Memória auxiliar, a ser utilizada para funções;
		        \item CTRL:  Vetor de controle dos retornos das funções 
		                     (callbacks);
		        \item LABEL: Hash com as posições associadas a cada LABEL
		                     criado como marcador no código da RVM.
		    \end{itemize}
				
		\subsubsection{ Stk.java }
		    Cuida das funções que mexem diretamente com a
		    memória, como 
		    {\textcolor{NavyBlue}{PUSH}, 
		    {\textcolor{NavyBlue}{POP} e 
		    {\textcolor{NavyBlue}{DUP}.
		    Que implementam um dado no topo da pilha, o retiram
		    e duplicam o q está no topo, respectivamente.
		    
		\subsubsection{ Syst.java }
		    Essa é a classe que controla os comandos destinados
		    aos próprios robôs, como por exemplo
		    {\textcolor{NavyBlue}{HIT},
		    {\textcolor{NavyBlue}{DRAG},
		    {\textcolor{NavyBlue}{DROP},
		    {\textcolor{NavyBlue}{MOVE},
		    {\textcolor{NavyBlue}{SEE} e
		    {\textcolor{NavyBlue}{LOOK}.
		    
		    Sendo que 
		    {\textcolor{NavyBlue}{private static void action(RVM rvm,
		    String type)} guarda o tipo de comando passado da
		    pilha de dados, cria uma {\textcolor{NavyBlue}{Operação} 
		    op e verifica se essa operação é válida, caso seja, 
		    coloca na pilha de dados as informações necessárias 
		    que serão lançadas como resposta.
		    
		\subsubsection{ Tests.java }
		    Controla as funções que executam os comandos do
		    usuário e que são do tipo comparativas.
		    Entre elas, estão 
		    {\textcolor{NavyBlue}{CMP}, 
		    {\textcolor{NavyBlue}{EQ}, 
		    {\textcolor{NavyBlue}{NE}, 
		    {\textcolor{NavyBlue}{LE}, 
		    {\textcolor{NavyBlue}{LT},
		    {\textcolor{NavyBlue}{GE}, 
		    {\textcolor{NavyBlue}{GT}
		    que dão pop no topo da pilha de dados, duas vezes,
		    e compara os dois dados de acordo com a função
		    especificada. 
		    
		    Depois desse processo, é empilhado um dado do tipo
		    Num (que é um Stackable) na pilha de dados.
		    De tal forma que, caso a comparação seja verdadeira,
		    é empilhado um Num de conteúdo 1, caso contrário,
		    um Num de conteúdo 0. 
		
		\subsubsection{ Var.java }
		    Essa classe cuida dos comandos voltados a criação de
		    variáveis no programa do usuário. Tais como alocação
		    de memóiria, liberação de memória, receber e alterar
		    o valor da variável.
		    Temos as seguintes funções:
		    
		    {\textcolor{NavyBlue}{static void ALOC(RVM rvm, 
		    Stackable name)}
		    que recebe o nome da variável como parâmtro e 
		    verifica na RVM se não existe outra com outro nome.
		    Caso negativo, é criada uma variável com valor null.
		    
		    {\textcolor{NavyBlue}{static void FREE(RVM rvm, 
		    Stackable name)}
		    que remove a variável com o nome name da RVM.
		    
		    {\textcolor{NavyBlue}{static void SET(RVM rvm, 
		    Stackable name)}
		    que pega o valor do topo da pilha e armazena na
		    variável com o nome name, caso ela exista.
		    
		    {\textcolor{NavyBlue}{static void GET(RVM rvm, 
		    Stackable name)}
		    que pega o valor da variável e o coloca no topo da
		    pilha de dados.
		
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Scenario}
	    Nesse package, temos as classes que representam
	    os vários tipos de elementos contidos nocenários do 
	    jogo.
	    Para o controle desses elementos. usamos a interface
	    Scenario que além de padronizar o tipo de dado,
	    força todas as classes a terem uma função que
	    cuida dos danos adquiridos ao decorrer do jogo
	    (por exemplo, quando uma pedra é atacada por um robô,
	    ela perde vidas, e perdendo um determinado número de
	    vidas, ela é destruida.
	    
	    Dentre eles há a base, as rochas, árvores e água.
	    
		\subsubsection{ Base.java }
		    A base tem um número escolhido ao acaso (42) de
		    vidas, portanto, quando formos retornar o HP,
		    sempre será 42. Já que a base, ao ser atacada,
		    não recebe danos.
		    E ao imprimirmos uma base, teremos como resultado
		    "(ß) Base".
		
		\subsubsection{ Rock.java }
		    A pedra retira o dano recebido do seu HP(vida) e
		    o devolve quando é chamada a função que retorna o
		    HP.
		    E ao imprimirmos uma pedra, teremos como resultado
		    "(O) Rock".
		
		\subsubsection{ Scenario.java }
		    Interface que padroniza os diferentes tipos de
		    elementos do cenários em um tipo Scenario, além 
		    de padronizar a função que cuida dos danos 
		    recebidos por cada objeto.
		    
		    Tem-se as seguintes funções:
		    
		    {\textcolor{NavyBlue}{ public int getHP() }
		    Retorna o número de vidas do presentes no robô.
		    
            {\textcolor{NavyBlue}{ public int takeDamage (int damage) }
            Essa é a função que cuida dos danos recebidos 
            pelo objeto, recebendo o dano como parâmetro
            para poder subtrair vidas do cenário.
		    
		\subsubsection{ Tree.java }
		    Assim como a pedra, a árvore recebe danos e os subtrai
		    de seu HP.
		    E quando a imprimimos através das funções IO, temos
		    "( ) Tree".
		    %"(♣) Tree". 
		
		\subsubsection{ Water.java }
		    A água, assim como a base, não recebe dano.
		    Portanto ela tem um número específico de HP
		    que se manterá intancto aos ataques sofridos.
		    Ao imprimirmos uma árvore, temos "( ) Water".
		    %"(≈) Water".
		    
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Stackable}
		Nesse package, temos a interface Stackable que
		será o tipo responsável pela atribuição da
		característica empilhável dos empilháveis.
		
		\subsubsection { Addr.java }
			Os objetos do tipo Addr são endereços de
			determinados valores em um vetor. Portanto
			são representados por inteiros.
			
			Nele encontramos as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Addr(int address) }
			que é o construtor de objetos do tipo Addr.
			
			{\textcolor{NavyBlue}{ public int getAddress() }
			que retorna o valor do endereço como um 
			inteiro.
		
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
		
		\subsubsection { Around.java }
			Tem como característica uma matriz de Strings
			que representam as direções as quais os robôs
			devem seguir para chegar aos determinados
			pontos visinhos.
			
			Nela, encontramos as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Around(Terrain[] seeing) }
   
    
    		{\textcolor{NavyBlue}{ public String[] indexToPosition
    		(int index) }
   			é responsável pelo retorno da String de coordenadas 
   			que o robô deve seguir para chegar a sua visinhança.
   			Ela recebe como parâmetro, o número de casas de 
   			distância que o robô pode atacar/ver.
		    
		    {\textcolor{NavyBlue}{ public void print() }
    		função para modo debuger!
    
		    {\textcolor{NavyBlue}{ public String toString() }
		    devolve a String "around", incluindo para saídas de IO.

		
		\subsubsection { Attack.java }
			Os objetos do tipo Attack são os tipos de
			ataque que o robô pode realizar. Por enquanto,
			temos o ataque MEELE que é a curta distancia(
			somente poderá atacar o que estiver nas casas
			visinhas a sua) ou RANGED que é a uma distância
			determinada pelas características do robô (caso
			o robo tenha um poder de atacar a 3 de distância,
			ele irá atingir o que está a até 3 casas de
			distância da sua).
			
			Nela, temos as seguintes funções:
					
			{\textcolor{NavyBlue}{ public Attack(String s) }
   			um construtor que monta o objeto a partir da
   			String passada.
			
			{\textcolor{NavyBlue}{ public String getAttack() }
			retorna o tipo de ataque em forma de String.
		
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.	
		
		\subsubsection { Direction.java }
			Os objetos do tipo Direction são do tipo que
			orientará os robôs na arena em relação a 
			movimentação e ataque. Pelo fato de a arena
			ser formada por bases hexagonais, temos as
			direções 
			{\textcolor{NavyBlue}{E}  (leste), 
			{\textcolor{NavyBlue}{NE} (nordeste), 
			{\textcolor{NavyBlue}{NW} (noroeste),
			{\textcolor{NavyBlue}{W}  (oeste), 
			{\textcolor{NavyBlue}{SW} (sudoeste) e 
			{\textcolor{NavyBlue}{SE} (sudeste).
			Sempre que um objeto do tipo Direction for
			chamado pelo usuário, este deve ser retratado
			com o símbolo 
			{\textcolor{NavyBlue}{''->''}
			antes do seu conteúdo.
			
			Por exemplo, 
			{\textcolor{NavyBlue}{''->WE''}.
			
			A classe Direction possui armazenará o movimento
			como uma matriz de coordenadas, que terá
			determinados tipos de movimento quando o robô 
			estiver em uma linha par e outro tipo de movimento
			quando o mesmo estiver numa linha ímpar.
			Essas coordenadas são dadas de modo que, quando
			a somamos com as coordenadas do robô, ele se 
			movimentará para o local desehjado.
			Obs.: Quando a linha é par, usamos a 1ª linha da
			matriz, caso contrário, usamos a 2ª.
			
			Temos as funções:
			
			public Direction(String dir)
			que é o contrutor
			
			{\textcolor{NavyBlue}{ public Direction(int move, 
			int dir) } 
			que recebe a direção e a partir dela, preenche a matriz 
			com as respectivas direções.
			
			{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			static void ALOC(RVM rvm, Stackable name)
			{\textcolor{NavyBlue}{ public int[] get(int row) }
			Devolve um vetor com a direção a ser seguida, se
			a linha em que ele está for par, devolvemos a
			"( ) Tree".
			%"(♣) Tree".
			1ª linha da matriz, caso contrário, a 2ª.
			
			{\textcolor{NavyBlue}{  private void set(int even\_x, 
			int even\_y, int odd\_x, int odd\_y) }
			preenche a matriz com as direções que são recebidas
			como parâmetro.
		
		\subsubsection { Item }
			Item não é uma classe, é uma pasta com as 
			classes que representam objetos do tipo item
			(implementam a interface de itens),
			o tipo item é um empilhável que pode ser pego
			e destruído pelo robô.
			Dentre elas, temos a
			 
			{\textcolor{NavyBlue}{Crystal.java}
			 que é repsonsável pela criação de
			objetos cristais.
			
			a {\textcolor{NavyBlue}{Item.java}
			que é uma interface responsável pela atribuição 
			do tipo item às classes.
			
			e a {\textcolor{NavyBlue}{Stone.java} que é 
			responsável pela criação das pedras que são 
			destruíveis e colecionáveis pelos robôs.
			 
		\subsubsection { Num.java }
			É um empilhável do tipo número.
			Ela possui as seguintes funções:
			
			{\textcolor{NavyBlue}{ public Num(double num) }
			que é o construtor, que cria o objeto usando
			um parametro numérico que é recebido.
    
    		{\textcolor{NavyBlue}{ public double getNumber() }
 	  		que retorna o valor de Num em formato double.
  
    		{\textcolor{NavyBlue}{ public String toString()}
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			
		\subsubsection { Stack.java }
			Essa classe administra as pilhas do programa,
			controlando informações sobre onde está o seu 
			topo ou qual o seu tamanho.
			
		\subsubsection { Stackable.java }
			É a interface Stackable que se responsabiliza
			pelos objetos empilháveis. Essa interface não
			possui características exclusivas como funções
			e variáveis que seriam herdadas pelas classes
			desse tipo, é apenas para generalizar o tipo
			dos empilháveis.
			
		\subsubsection { Text.java }
			É criado o tipo de Stackable Text, onde 
			poderemos empilhar um texto ou String.
			Possui as seguintes funções:
			
			{\textcolor{NavyBlue}{public String getText() }
			que retorna o texto em si em formato String.
			
    		{\textcolor{NavyBlue}{ public String toString() }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.


\end{document}
