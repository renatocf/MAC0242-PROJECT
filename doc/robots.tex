\documentclass[a4paper]{article}

% Linguagem
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}

% Pacotes matemáticos
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

% Fontes e identaçãp
\usepackage{setspace}                   % espaçamento flexível
\usepackage{indentfirst}                % indentação do primeiro parágrafo
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

% Pacotes para cores e modelos
\usepackage[a4paper,top=3.0cm,bottom=2.0cm,left=3.0cm,right=2.0cm]{geometry} \usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,
            colorlinks=true,citecolor=DarkGreen,linkcolor=DarkRed,
            urlcolor=DarkRed,filecolor=DarkGreen,
            bookmarksopen=true]{hyperref}

% Pacotes para itens
\usepackage{calc}  
\usepackage{enumitem}  

\title  {Projeto de Laboratório de Programação II - Fase 2}
\author {Karina Suemi, Vinícius Silva, Renato Cordeiro}
\date   {}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Introdução} \label{sec:introdução}

    Nesta fase, o projeto consiste na criação de uma máquina
    virtual em JAVA, juntamente com a implementação de funções
    que darão ao usuário o poder de controlar o robô através 
    de comandos usados com pilha de dados.
    Há também a criação da Arena, esta é resposável por controlar
    os robôs de forma que eles sejam impossibilitados de fazer
    movimentos não propícios. 
    
    E por último, temos os tipos de terrenos e objetos que estarão
    dispostos nele, como cristais, rochas ( como objetos ), bases, 
    água, árvores, entre outros ( como cenário ). 
    
    
    \subsection{Projeto}
    
    Os arquivos estão separados de acordo com a seguinte estrutura de
    diretórios:
    \begin{itemize}
        \item \textbf{bin:}  Arquivo executável principal do programa;
        \item \textbf{doc:}  Pasta para a documentação, com este arquivo 
                             e a versão fonte em \LaTeX;
        \item \textbf{lib:}  Arquivos com classes/pacotes de Perl 
                             no formato \texttt{.pm};
        \item \textbf{test:} Arquivos de teste com código em Assembly
                             do montador/máquina virtual \texttt{.txt}.
    \end{itemize}
    
    \subsection{Estrutura}
      
        Para informações sobre o uso de programa e os seus 
        desenvolvedores, consultar os arquivos \href{run:../README.md}
        {\texttt{README.md}} e \href{run:../LICENSE}{\texttt{LICENSE}}.
        
        O programa consiste de três partes principais:
        \begin{itemize}
            \item \hyperref[sec:montador]        {Montador};
            \item \hyperref[sec:maquina_virtual] {Máquina Virtual};
            \item                                 Emulador.
        \end{itemize}
    
    \subsection{Emulador}
    
        O emulador é a parte mais simples do programa, e consiste de 
        um arquivo do tipo \texttt{.pl} nomeado 
        \href{run:../bin/robots.pl}{\texttt{robots.pl}} na pasta
        \texttt{bin/}. Para executá-lo, basta rodar o programa 
        passando como parâmetro na linha de comando um arquivo (de 
        extensão qualquer) com o assembly válido. 
        
        Caso haja erro de compilação, o programa será encerrado antes 
        da execução de qualquer comando. Caso o erro seja lógido 
        (\emph{runtime}), os erros serão impressos na saída de erros 
        (STDERR) no próprio prompt de comando.

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Montador} \label{sec:montador}

    O montador tem como função ler o programa em texto (que será 
    passado pelo usuário), ver se ele está formatado de maneira 
    correta e em caso positivo, é criada uma matriz 3 x n, sendo $n$ 
    o número de comandos, que será passada para a Máquina Virtual.
    
    O arquivo com o montador está no diretório de bibliotecas 
    \texttt{lib/} e é chamado \href{run:../lib/Cortex.pm}
    {\texttt{Cortex.pm}}
    
    \bigskip\bigskip
    
    No caso, as linhas do programa de entrada terão que seguir o 
    seguinte padrão:

    \begin{center}
        \textbf{[ Comando, Argumento, Label ]}
    \end{center}
    
    O montador devolverá erro em caso de comandos que não sejam 
    compatíveis com seus respectivos tipos de argumentos. No caso da
    entrada ser: 
    
    \begin{description}
    [leftmargin=!,labelwidth=\widthof{\bfseries The longest label}]

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        \item [\textbf{\textcolor{red}{x}} "ADD Olá"] 
        O comando ADD não deveria receber argumentos, e como não é o 
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "ADD"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "PUSH Oie!"] 
        O comando PUSH deveria receber argumentos numéricos, e como não é 
        o caso, o programa passará \emph{undef} para a Máquina Virtual.
    
        \item [\textcolor{green}{\checkmark} "PUSH 100"] 
        Este seria o correto.
        
        \item[] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        \item [\textbf{\textcolor{red}{x}} "JIF 5uvas"] 
        O comando JIF deveria receber argumentos em forma de texto (pode
        conter números, desde que não sejam 1º caracter), e como não é o
        caso, o programa passará \emph{undef} para a Máquina Virtual.
        
        \item [\textcolor{green}{\checkmark} "JIF uvas5"] 
        Este seria o correto.

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \end{description}

    \bigskip\bigskip

    Segue a tabela com os argumentos necessários para cada tipo de 
    comando:
    
    \begin{center}
      \begin{tabular}{|c|l|rc|}
                     &  ADD - DIV - DUP - END - EQ - GE - GT   \\
          Vazio      &  MOD - LE - LT - MUL - NE - POP - PRN   \\
                     &  SUB - RET - MOVE - DRAG - DROP - HIT   \\
                     &  LOOK - ITEM - SEE - SEEK               \\
                     &										   \\
          Numérico   &  RCL - STO                              \\
          			 &										   \\
          String     &  JMP - JIF - JIT - CALL                 \\
          			 &										   \\
          Empilhável &  crystal - stone                        \\
      \end{tabular}
    \end{center}  
    
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
\section{Máquina Virtual} \label{sec:maquina_virtual}
    
    A máquina virtual (RVM, \emph{Robot Virtual Machine}, consiste em 
    um conjunto de módulos localizados no diretório lib/RVM que integram 
    o pacote/classe RVM. 
    
    Os arquivos do módulo são:
    \begin{itemize}
        \item \href{run:../lib/RVM/RVM.pm}       {RVM.pm        }
        \item \href{run:../lib/RVM/Overload.pm}  {Overload.pm   }
        \item \href{run:../lib/RVM/ctrl.pm}      {ctrl.pm       }
        \item \href{run:../lib/RVM/functions.pm} {functions.pm  }
        \item \href{run:../lib/RVM/f\_arit.pm}   {f\_arit.pm    }
        \item \href{run:../lib/RVM/f\_io.pm}     {f\_io.pm      }
        \item \href{run:../lib/RVM/f\_jumps.pm}  {f\_jumps.pm   }
        \item \href{run:../lib/RVM/f\_memo.pm}   {f\_memo.pm    }
        \item \href{run:../lib/RVM/f\_stk.pm}    {f\_stk.pm     }
        \item \href{run:../lib/RVM/f\_tests.pm}  {f\_tests.pm   }
    \end{itemize}
    
    \subsection{RVM.pm}
        
        A \emph{Robot Virtual Machine} (\textbf{RVM}) é o pacote 
        principal que controla o 'cérebro' dos robôs, servindo como o
        interpretador para o formato criado pelo montador. Cada 
        instância da classe RVM possui os seguintes atributos:
        
        \begin{itemize}
            
            \item PROG:  Vetor com os comandos do programa, conforme
                         o formato criado pelo montador;
            \item DATA:  Vetor com a pilha principal de memória, no 
                         qual serão armazenados os dados colocados 
                         com comandos de manipulação da pilha;
            \item PC:    Registrador para a posição atual de execução 
                         dos comandos dentro do vetor PROG;
            \item RAM:   Memória auxiliar, a ser utilizada para funções;
            \item CTRL:  Vetor de controle dos retornos das funções 
                         (callbacks);
            \item LABEL: Hash com as posições associadas a cada LABEL
                         criado como marcador no código da RVM.
            
        \end{itemize}
        
        O módulo RVM contém dois métodos, responsáveis por agirem como
        construtor (\textbf{new}) e inicializador de programa 
        (\textbf{upload}) para os objetos da RVM.
        
    \subsection{Overload.pm}
        
        Módulo auxiliar que faz parte da classe da RVM. Sua principal
        função é fornecer a sobrecarga do operador \emph{double quote}
        (\textbf{qq//} ou \textbf{"}), de modo a possibilitar a 
        impressão dos valores armazenados dentro da RVM.
    
    \subsection{ctrl.pm}
    
        O módulo auxiliar do controlador contém o método responsável 
        por realizar a execução do programa armazenado no atributo 
        \textbf{PROG} do objeto da classe RVM. 
        
        Começando da posição 0, a cada posição de PROG realiza a 
        chamada da função correspondente, usando os argumentos (se 
        disponíveis ou necessários). Nesse processo, atualiza o PC 
        (registrador de posição) para realizar a atualização 
        necessária (avançar para o próximo comando ou fazer um desvio).
        
        Quando a função retorna um erro, lança uma exceção (erro de 
        \emph{runtime}), que pode ser de 3 tipos:
        \begin{itemize}
            
            \item Falha de segmentação: tentativa de acessar região 
                                        não definida da memória -
                                        overflow/underflow da
                                        pilha de dados DATA;
                                        
            \item Operação inválida:    quando o operando não é do tipo 
                                        válido;
                                        
            \item Label desconhecido:   o LABEL acessado pelo comando 
                                        de controle de \emph{workflow} 
                                        não foi definido.
                                        
        \end{itemize}
        
    \subsection{functions.pm}
        
        Módulo auxiliar que reúne as funções criadas em outros módulos 
        da Máquina Virtual. Com ele é possível ter acesso às funções 
        que podem ser executadas pela RVM.        
        
        Para cada comando implementado nos módulos listados, as funções
        recebem como argumento o objeto do pacote sobre o qual a ação 
        deve ser realizada, o argumento (se não existir, é \emph{undef},
        e é descartado) e o número de elementos da pilha.
        
        Todas as funções retornam a atualização do número de elementos
        da pilha, estritamente maior que 0, ou números negativos, 
        indicando as exceções listadas na seção anterior.

    \subsection{f\_arit.pm}
        
        O f\_arit.pm contém as funções aritméticas que o programa deve
        executar, como a soma, subtração, multiplicação e divisão.
        
        Ele desempilha o último e penúltimo valores a partir do topo 
        da pilha de dados. Caso não existam dois valores, a função 
        lança uma exceção.
        
        \textbf{Observação}: As 4 operações funcionam de maneira
        análoga.        
        
    \subsection{f\_io.pm}
        
        Este módulo é responsável pela execução da função PRN 
        (\emph{PRiNt}), que imprime na STDOUT o valor do topo da 
        pilha de dados.
            
    \subsection{f\_jumps.pm}
        
        O f\_jumps.pm contém as funções responsáveis pela execução dos
        comandos associados a jumps, como JMP (\emph{JuMP}), JIT 
        (\emph{Jump If True})e JIF (\emph{Jump If False}).
        
        No caso de \emph{JMP}, este irá atribuir o argumento passado 
        ao registrador de instrução (PC), realizando um salto 
        incondicional a esta posição. Caso não existam instruções
        na posição indicada, lança uma exceção do tipo \emph{Falha
        de Segmentação}.
        
        Para os outros comandos de salto condicional (\emph{JIT}/
        \emph{JIF}), também é possível passar como argumento um
        LABEL. Caso esta posição não exista, lança uma exceção
        específica.
    
    \subsection{f\_memo.pm}
        
        O f\_memo.pm  contém as funções que mexem com endereçamento
        de memória: \emph{STO} e \emph{RCL}.
        
        Este módulo é o responsável por realizar a transferência de
        dados entre o vetor de memória principal (DATA) e o vetor 
        auxiliar (RAM). Cada um deles recebe como argumento o endereço
        (posição do vetor), de modo que:
        \begin{itemize}
            
            \item STO: retira o valor de DATA e coloca na posição 
                       \$arg de RAM;
            \item RCL: realiza o processo inverso.
            
        \end{itemize}
        
        Ambas as funções devolvem uma exceção do tipo \emph{Falha de
        Segmentação} caso não haja elementos em DATA (\emph{STO}) ou 
        na posição de RAM (\emph{RCL}).
        
    \subsection{f\_stk.pm}
        
        O submódulo f\_stk.pm contém as funções de manipulação de pilha.
        \emph{PUSH}, \emph{POP} e \emph{DUP}.
        \begin{itemize}
            
            \item PUSH: Recebe um argumento e o coloca no topo da pilha 
                        de dados DATA;
            
            \item POP:  Retira o dado que estiver no topo da pilha de 
                        dados; 
            
            \item DUP:  Empilha uma cópia do topo da pilha.
        
        \end{itemize}
        
    \subsection{f\_tests.pm}
            
        O submódulo f\_tests.pm armazena as funções lógicas. Cada uma
        dekas retira os dois elementos do topo da pilha e, em seguida,
        realiza uma comparação, usando como primeiro argumento o topo
        da pilha.
        
        Considerando 'A' o topo da pilha e 'B' o elemento anterior,
        os comandos realizam as seguintes ações, em seus análogos 
        para números:
        \begin{itemize}
            \item EQ: A == B
            \item GT: A >  B
            \item GE: A >= B
            \item LT: A <  B
            \item LE: A <= B
            \item NE: A != B
        \end{itemize}
    











\newpage
\newpage

\section{Packages}
	Foram criados pacotes para facilitar a divisão
	e entendimento do código.
	
	\subsection{Arena}
		O package "Arena" cuida da 
		\subsubsection{ Action.java }
		\subsubsection{ Appearence.java }
		\subsubsection{ Map.java }
		\subsubsection{ Robot.java }
		\subsubsection{ Terrain.java }
		\subsubsection{ Type.java }
		\subsubsection{ Weather.java }						
		\subsubsection{ World.java }				
				
	\subsection{Exception}
		O package "Exception" cuida dos lançamentos de exceção
		que o programa gera para erros no código que será recebido
		do usuário.

		Como por exemplo as exceções de falha de segmentação,
		operações inválidas, erros de tipo, variáveis não
		inicializadas, entre outros.
		
		As classes desse package são chamadas pelas outras classes
		que utilizam essa forma de mandar exceção.
		 
	\subsection{Operation}
		\subsubsection{ Operation.java }
		\subsubsection{ package-info.java }
		
	\subsection{Parameters}
		\subsubsection{ Debugger.java }
		\subsubsection{ Game.java     }
		\subsubsection{ Verbosity.java}
		
	\subsection{Parser}
		\subsubsection{ Parser.java }
		
	\subsection{Random}
		\subsubsection{ CalmField.java }
		\subsubsection{ Desert.java }
		\subsubsection{ Jungle.java }
		\subsubsection{ RamdomMap.java }
		\subsubsection{ Theme.java }
		\subsubsection{ Winter.java }
	
	\subsection{Robot}
		\subsubsection{ Arit.java }
		\subsubsection{ Check.java }
		\subsubsection{ Command.java }
		\subsubsection{ Ctrl.java }
		\subsubsection{ Func.java }
		\subsubsection{ IO.java }
		\subsubsection{ Jumps.java }
		\subsubsection{ Mem.java }
		\subsubsection{ package-info.java }
		\subsubsection{ Prog.java }
		\subsubsection{ RVM.java }
		\subsubsection{ Stk.java }
		\subsubsection{ Syst.java }
		\subsubsection{ T ests.java }
		\subsubsection{ Var.java }
		
	\subsection{Scenario}
		\subsubsection{ Base.java }
		\subsubsection{ Rock.java }
		\subsubsection{ Scenario.java }
		\subsubsection{ Tree.java }
		\subsubsection{ Water.java }
		
	\subsection{Stackable}
		Nesse package, temos a interface Stackable que
		será o tipo responsável pela atribuição da
		característica empilhável dos empilháveis.
		
		\subsubsection { Addr.java }
		\subsubsection { Around.java }
		\subsubsection { Attack.java }
		\subsubsection { Direction.java }
			Os objetos do tipo Direction são do tipo que
			orientará os robôs na arena em relação a 
			movimentação e ataque. Pelo fato de a arena
			ser formada por bases hexagonais, temos as
			direções E(leste), NE(nordeste), NW(noroeste),
			W(oeste), SW(sudoeste) e SE(sudeste).
			Sempre que um objeto do tipo Direction for
			chamado pelo usuário, este deve ser retratado
			com o símbolo "->" antes do seu conteúdo.
			
			Por exemplo, "->WE".
			
			A classe Direction possui armazenará o movimento
			como uma matriz de coordenadas, que terá
			determinados tipos de movimento quando o robô 
			estiver em uma linha par e outro tipo de movimento
			quando o mesmo estiver numa linha ímpar.
			Essas coordenadas são dadas de modo que, quando
			a somamos com as coordenadas do robô, ele se 
			movimentará para o local desehjado.
			
			
			Temos as funções:
			
			public Direction(String dir)
			que é o contrutor
			
			public Direction(int move, int dir)
			que recebe a direção e partir dela, preenche o vetor
		
		\subsubsection { Item }
			Item não é uma classe, é uma pasta com as 
			classes que representam objetos do tipo item
			(implementam a interface de itens),
			o tipo item é um empilhável que pode ser pego
			e destruído pelo robô.
			Dentre elas, temos a
			 
			Crystal.java que é repsonsável pela criação de
			objetos cristais.
			
			a Item.java que é uma interface responsável pela 
			atribuição dotipo item às classes.
			
			e a Stone.java que é responsável pela criação
			das pedras que são destruíveis e colecionáveis
			pelos robôs.
			 
		\subsubsection { Num.java }
			É um empilhável do tipo número.
			Ela possui as seguintes funções:
			
			public Num(double num)
			que é o construtor, que cria o objeto usando
			um parametro numérico que é recebido.
    
    		public double getNumber()
 	  		que retorna o valor de Num em formato double.
    
    		public String toString()
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.
			
		\subsubsection { Stack.java }
			Essa classe administra as pilhas do programa,
			controlando informações sobre onde está o seu 
			topo ou qual o seu tamanho.
			
			
		\subsubsection { Stackable.java }
			É a interface Stackable que se responsabiliza
			pelos objetos empilháveis. Essa interface não
			possui características exclusivas como funções
			e variáveis que seriam herdadas pelas classes
			desse tipo, é apenas para generalizar o tipo
			dos empilháveis.
			
		\subsubsection { Text.java }
			É criado o tipo de Stackable Text, onde 
			poderemos empilhar um texto ou String.
			Possui as seguintes funções:
			
			public String getText()  { return this.text; }
			que retorna o texto em si em formato String.
			
    		public String toString() { return this.text; }
			que além de retornar a String com o valor de
			da variável, manda o texto para as funções IO.


\end{document}
